<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MTG Proxy Maker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --cell-w: 2.4750in; /* default card width */
      --cell-h: 3.4650in; /* default card height */
      --cols: 3;
      --rows: 3;
      --grid-w: calc(var(--cols) * var(--cell-w));
      --grid-h: calc(var(--rows) * var(--cell-h));
      --page-w: 8.5in;
      --page-h: 11in;
      --page-bg: white;
      --grid-gap: 0in;
      --guide-color: rgba(0,0,0,.25);
      --preview-scale: 1;
      --preview-bottom-gap: 5vh;

      /* print-safe margin above the grid */
      --grid-top: 0.25in;

      /* horizontal offset for fine printer tuning */
      --grid-left: 0in;
    }

    html, body { height: 100%; margin: 0; overflow: hidden; background: #f3f4f6; color: #111827; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; }

    .app { height: 100vh; display: grid; grid-template-rows: auto auto 1fr; gap: 12px; box-sizing: border-box; }
    header { background: white; border-bottom: 1px solid #e5e7eb; position: sticky; top: 0; z-index: 10; }
    .bar { max-width: 1200px; margin: 0 auto; display: flex; gap: 12px; align-items: center; padding: 10px 16px; }
    .bar h1 { font-size: 16px; margin: 0; font-weight: 700; }
    .bar .spacer { flex: 1; }

    button, label.button { border: 1px solid #d1d5db; background: #111827; color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; }
    button.secondary, label.secondary { background: white; color: #111827; border-color: #9ca3af; }
    button.danger { background: #b91c1c; color: #fff; border-color: #991b1b; }

    select, input[type="checkbox"], input[type="text"], textarea, input[type="number"] { border: 1px solid #d1d5db; border-radius: 8px; padding: 6px 8px; font-size: 14px; background: white; color: #111827; }

    .controls{ max-width:1200px; width:100%; margin: 0 auto; }
    .panel{ background: white; border:1px solid #e5e7eb; border-radius:12px; padding:12px; display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
    .field{ display:flex; align-items:center; gap:8px; }

    .status { font-size: 12px; color: #6b7280; margin-left: 8px; }

    main { display: flex; align-items: flex-start; justify-content: center; overflow: hidden; box-sizing: border-box; min-height: 0; }

    .page-wrap{ width: calc(var(--page-w) * var(--preview-scale)); height: calc(var(--page-h) * var(--preview-scale)); position: relative; display: grid; place-items: start center; margin: auto 0 var(--preview-bottom-gap) 0; flex-shrink: 0; max-height: 100%; overflow: visible; }

    .page {
      width: var(--page-w);
      height: var(--page-h);
      background: var(--page-bg);
      box-shadow: 0 10px 30px rgba(0,0,0,.12);
      position: relative;
      display: grid;
      place-items: start center;
      padding-top: var(--grid-top);
      transform-origin: top left;
      transform: scale(var(--preview-scale));
      margin: 0;
      content-visibility: auto;
      contain-intrinsic-size: 1100px 1400px;
    }
    .page:not(.current) { display: none; }

    .pages-controls { display:flex; align-items:center; gap:8px; }
    .pages-controls .pill { font-variant-numeric: tabular-nums; padding: 4px 8px; border:1px solid #e5e7eb; border-radius: 999px; background:#f9fafb; }

    .grid { width: var(--grid-w); height: var(--grid-h); display: grid; grid-template-columns: repeat(var(--cols), var(--cell-w)); grid-template-rows: repeat(var(--rows), var(--cell-h)); gap: var(--grid-gap); position: relative; z-index: 1; transform: translateX(var(--grid-left)); }

    .page .cut-overlay { position: absolute; inset: 0; pointer-events: none; opacity: 0; transition: opacity .15s ease-in-out; z-index: 3; transform: translateX(var(--grid-left)); }
    .cut-overlay svg { position:absolute; inset:0; width:100%; height:100%; display:block; }
    .show-cuts .cut-overlay { opacity: 1; }
    .show-cuts .cell { border-color: transparent !important; }

    .cell { width: var(--cell-w); height: var(--cell-h); border: 0.5pt dashed var(--guide-color); background: #f9fafb; position: relative; overflow: hidden; display: grid; place-items: center; user-select: none; touch-action: none; border-radius: 8px; contain: layout paint size; }
    .cell img { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: none; image-rendering: auto; -webkit-user-drag: none; user-select: none; }
    .cell .placeholder{ color: #9ca3af; font-size: 12px; text-align: center; padding: 8px; user-select: none; }

    .cell:focus { outline: none; }
    .cell::after{
      content:""; position:absolute; inset:0; border-radius: 8px;
      pointer-events:none; z-index:5; opacity:0; transition:opacity .12s ease-in-out;
    }
    .cell:focus::after{
      opacity:1;
      box-shadow:
        inset 0 0 0 3px #ffffff,
        inset 0 0 0 6px #2563eb;
    }
    .cell.drop-target::after{
      opacity:1;
      box-shadow:
        inset 0 0 0 3px #ffffff,
        inset 0 0 0 6px #60a5fa;
    }

    .cell.dragging { opacity: .6; }

    /* Instruct printers on paper size */
    @page { size: 8.5in 11in; margin: 0; }

    /* ====== PRINT ====== */
    @media print{
      header, .controls, .screen-only { display: none !important; }

      html, body { width: auto; height: auto; margin: 0; }
      body { display: block !important; background: white; overflow: visible !important; }
      .app { display: block !important; height: auto !important; }
      main { display: block !important; overflow: visible !important; min-height: 0 !important; }

      .page-wrap{
        width: auto !important;
        height: auto !important;
        margin: 0 !important;
        display: block !important;
        overflow: visible !important;
        place-items: initial !important;
      }

      .page{
        width: var(--page-w);
        height: var(--page-h);
        transform: none !important;
        box-shadow: none !important;
        position: static !important;
        display: block !important;
        padding-top: var(--grid-top);
        margin: 0 !important;
        box-sizing: border-box;
        break-inside: avoid;
        page-break-inside: avoid;
        break-after: auto !important;
        page-break-after: auto !important;
      }

      .page .grid { margin-left: auto !important; margin-right: auto !important; }

      .page + .page{
        break-before: page;
        page-break-before: always;
      }

      .page:not(.current){ display: block !important; }

      .cell{ border: none !important; }
      .cell .placeholder{ display: none !important; }
      .cell::after{ display:none !important; }
      .ctx-menu { display: none !important; }

      img { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
    }

    /* ===== Context Menu ===== */
    .ctx-menu {
      position: fixed;
      top: 0;
      left: 0;
      min-width: 200px;
      max-width: 320px;
      background: #ffffff;
      border: 1px solid #d1d5db;
      border-radius: 10px;
      box-shadow: 0 18px 40px rgba(15,23,42,.18);
      padding: 6px;
      display: none;
      flex-direction: column;
      gap: 4px;
      z-index: 70;
    }
    .ctx-menu.open { display: flex; }
    .ctx-section {
      display: flex;
      flex-direction: column;
      gap: 2px;
      padding: 4px 0;
    }
    .ctx-section + .ctx-section { border-top: 1px solid #e5e7eb; margin-top: 2px; padding-top: 6px; }
    .ctx-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #6b7280;
      padding: 4px 10px;
    }
    .ctx-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 13px;
      color: #111827;
      cursor: pointer;
      outline: none;
    }
    .ctx-item[aria-disabled="true"] {
      color: #9ca3af;
      cursor: default;
      pointer-events: none;
    }
    .ctx-item:not([aria-disabled="true"]):hover,
    .ctx-item:not([aria-disabled="true"]):focus-visible {
      background: #e0e7ff;
      color: #1d4ed8;
    }
    .ctx-item:focus-visible { box-shadow: inset 0 0 0 2px rgba(59,130,246,.35); }
    .ctx-kbd {
      font-size: 11px;
      font-weight: 600;
      color: #4b5563;
      background: #eef2ff;
      border-radius: 4px;
      padding: 2px 6px;
      line-height: 1;
      white-space: nowrap;
    }
    .ctx-sep {
      height: 1px;
      background: #e5e7eb;
      margin: 4px 0;
    }

    :root[data-theme="dark"] .ctx-menu {
      background: #0f172a;
      border-color: #1f2937;
      box-shadow: 0 18px 40px rgba(0,0,0,.55);
    }
    :root[data-theme="dark"] .ctx-section + .ctx-section { border-top-color: #1f2937; }
    :root[data-theme="dark"] .ctx-label { color: #94a3b8; }
    :root[data-theme="dark"] .ctx-item { color: #e5e7eb; }
    :root[data-theme="dark"] .ctx-item[aria-disabled="true"] { color: #475569; }
    :root[data-theme="dark"] .ctx-item:not([aria-disabled="true"]):hover,
    :root[data-theme="dark"] .ctx-item:not([aria-disabled="true"]):focus-visible {
      background: rgba(59,130,246,.16);
      color: #bfdbfe;
    }
    :root[data-theme="dark"] .ctx-item:focus-visible { box-shadow: inset 0 0 0 2px rgba(59,130,246,.45); }
    :root[data-theme="dark"] .ctx-kbd {
      color: #cbd5f5;
      background: rgba(148,163,184,.18);
    }
    :root[data-theme="dark"] .ctx-sep { background: #1f2937; }

    .modal { position: fixed; inset: 0; background: rgba(0,0,0,.35); display: none; align-items:center; justify-content:center; z-index: 50; }
    .modal.open { display:flex; }
    .modal .sheet { width: min(900px, 92vw); background: white; border-radius: 12px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.2); display:flex; flex-direction:column; gap:12px; align-items: stretch; border:1px solid #e5e7eb; }
    .modal .sheet h2 { margin:0; font-size:18px; }

    .help-list { margin:0; padding-left:18px; font-size:13px; line-height:1.6; }
    .footnote { font-size: 12px; color:#6b7280; margin-top: 4px; }

    .modal .sheet textarea { width: 100%; min-height: 240px; resize: vertical; box-sizing: border-box; display: block; margin: 0; }
    .right { margin-left: auto; }

    .warning { background:#fff7ed; color:#7c2d12; border:1px solid #fdba74; padding:8px 10px; border-radius:8px; font-size:13px; }

    :root[data-theme="dark"] body { background:#0b0d10; color:#e5e7eb; }
    :root[data-theme="dark"] header { background:#111827; border-bottom-color:#1f2937; }
    :root[data-theme="dark"] .panel { background:#111827; border-color:#1f2937; }
    :root[data-theme="dark"] .bar h1 { color:#e5e7eb; }
    :root[data-theme="dark"] .status { color:#9ca3af; }
    :root[data-theme="dark"] .pill { background:#0f172a; border-color:#1f2937; color:#e5e7eb; }
    :root[data-theme="dark"] select,
    :root[data-theme="dark"] input[type="checkbox"],
    :root[data-theme="dark"] input[type="text"],
    :root[data-theme="dark"] input[type="number"],
    :root[data-theme="dark"] textarea {
      background:#0f172a; color:#e5e7eb; border-color:#334155;
    }
    :root[data-theme="dark"] button.secondary,
    :root[data-theme="dark"] label.secondary {
      background:#1f2937; color:#e5e7eb; border-color:#374151;
    }
    :root[data-theme="dark"] button.danger { background:#b91c1c; border-color:#7f1d1d; }
    :root[data-theme="dark"] .cell { background:#0b1220; }
    :root[data-theme="dark"] .cell .placeholder { color:#94a3b8; }
    :root[data-theme="dark"] .page { background:var(--page-bg); }
    :root[data-theme="dark"] .modal .sheet { background:#111827; color:#e5e7eb; border-color:#1f2937; }
    :root[data-theme="dark"] .modal .sheet h2,
    :root[data-theme="dark"] .modal .sheet h3 { color:#e5e7eb; }
    :root[data-theme="dark"] .help-list { color:#cbd5e1; }
    :root[data-theme="dark"] .footnote { color:#9ca3af; }
    :root[data-theme="dark"] .warning { background:#292524; color:#fed7aa; border-color:#a16207; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="bar">
        <h1>MTG Proxy Maker</h1>
        <div class="spacer"></div>
        <div class="pages-controls screen-only">
          <button id="prevPageBtn" class="secondary" title="Prev page [ or Ctrl+← / ⌘+←">‹</button>
          <span id="pageBadge" class="pill">Page 1 / 1</span>
          <button id="nextPageBtn" class="secondary" title="Next page ] or Ctrl+→ / ⌘+→">›</button>
          <button id="addPageBtn" class="secondary" title="Add page (N)">+ Page</button>
          <button id="removePageBtn" class="secondary" title="Remove current page (Shift+Delete/Backspace)">− Page</button>
          <button id="helpBtn" class="secondary" title="Help / Hotkeys">?</button>
        </div>
        <label class="button secondary screen-only">
          Add Images
          <input id="fileInput" type="file" accept="image/*" multiple style="display:none" />
        </label>
        <button id="clearBtn" class="secondary screen-only" title="Clear current page (Ctrl/⌘+Delete/Backspace)">Clear</button>
        <button id="clearAllBtn" class="danger screen-only" title="Clear ALL pages (Ctrl/⌘+Shift+Delete/Backspace)">Clear All</button>
        <button id="printBtn" title="Open print dialog (P)">Print</button>
      </div>
    </header>

    <div class="controls screen-only">
      <div class="panel">
        <div class="field">
          <label class="field" title="Draw thin guides around cells for alignment">
            <input type="checkbox" id="toggleGuides" checked /> Show guides
          </label>
        </div>
        <div class="field">
          <label class="field" title="Draw cut lines at cell borders"><input type="checkbox" id="toggleCutMarks" /> Cut marks</label>
        </div>
        <div class="field">
          <label class="field" title="Add the reverse face of double-faced cards after the front image">
            <input id="includeDFCBacksChk" type="checkbox" /> Include DFC back faces
          </label>
        </div>
        <div class="field">
          <input id="cardSearch" type="text" placeholder="Add card by name (Enter)" style="min-width:240px" />
          <button id="addCardBtn" class="secondary">Add</button>
          <button id="decklistBtn" class="secondary" title="Paste a decklist to auto-fill">Decklist</button>
        </div>
        <div class="status" id="status" role="status" aria-live="polite">Ready</div>
        <div class="spacer"></div>
      </div>
    </div>

    <main>
      <div id="pageWrap" class="page-wrap"></div>
    </main>
  </div>

  <!-- Decklist modal injected dynamically -->
  <div id="deckModalRoot"></div>

  <!-- Help modal injected dynamically -->
  <div id="helpModalRoot"></div>

  <!-- Tuning modal -->
  <div id="tuneModal" class="modal">
    <div class="sheet" role="dialog" aria-modal="true" aria-labelledby="tuneTitle">
      <h2 id="tuneTitle">Printer Tuning</h2>
      <div class="warning">⚠️ Only adjust these if your prints look clipped or misaligned. Most printers work with the defaults.</div>

      <!-- Three-column grid; scale lock pinned right -->
      <div class="panel" style="display:grid;grid-template-columns:1fr 1fr auto;gap:12px;align-items:end;">
        <label class="field" title="Adds extra white space above the grid so printers that can't print to the edge don't clip.">
          Top margin (in)
          <input id="tuneTopIn" type="number" step="0.01" min="0" value="0.25" style="width:120px">
        </label>
        <label class="field" title="Shifts the entire grid left/right relative to the page center. Positive = right.">
          Horizontal offset (in)
          <input id="tuneLeftIn" type="number" step="0.01" value="0.00" style="width:120px">
        </label>
        <label class="field" title="Exact card width in inches (affects grid and cut marks).">
          Card width (in)
          <input id="tuneCardWIn" type="number" step="0.001" min="2.400" max="2.600" style="width:120px">
        </label>
        <label class="field" title="Exact card height in inches (affects grid and cut marks).">
          Card height (in)
          <input id="tuneCardHIn" type="number" step="0.001" min="3.400" max="3.600" style="width:120px">
        </label>

        <label class="field" style="grid-column: 1 / span 2;" title="Change how images scale inside each cell.">
          <strong>Image fit mode</strong>
          <select id="fitMode">
            <option value="cover" selected>Cover (fill & crop)</option>
            <option value="contain">Contain (fit inside, may letterbox)</option>
          </select>
        </label>

        <!-- Scale lock moved to the right, spanning both input rows -->
        <label class="field" style="grid-column: 3; grid-row: 1 / span 2; align-self:end; justify-self:end;" title="When checked, width/height stay proportional to 2.5×3.5 while you edit.">
          <input id="tuneScaleLock" type="checkbox" checked />
          Scale (keep 2.5×3.5 ratio)
        </label>
      </div>

      <div style="display:flex;gap:8px;align-items:center;">
        <button id="saveTuneBtn">Save</button>
        <button id="resetTuneBtn" class="secondary">Reset</button>
        <div class="right"></div>
        <button id="closeTuneBtn" class="secondary">Close</button>
      </div>
    </div>
  </div>

  <div id="ctxMenu" class="ctx-menu" role="menu" aria-hidden="true"></div>

  <script>
    /* ===== Core refs ===== */
    var cols = 3, rows = 3, CELLS_PER_PAGE = cols*rows;
    var pageWrap = document.getElementById('pageWrap');
    var fileInput = document.getElementById('fileInput');
    var printBtn = document.getElementById('printBtn');
    var clearBtn = document.getElementById('clearBtn');
    var clearAllBtn = document.getElementById('clearAllBtn');
    var fitModeSelect = document.getElementById('fitMode');
    var toggleGuides = document.getElementById('toggleGuides');
    var toggleCutMarks = document.getElementById('toggleCutMarks');
    var statusEl = document.getElementById('status');
    var prevPageBtn = document.getElementById('prevPageBtn');
    var nextPageBtn = document.getElementById('nextPageBtn');
    var addPageBtn = document.getElementById('addPageBtn');
    var removePageBtn = document.getElementById('removePageBtn');
    var pageBadge = document.getElementById('pageBadge');
    var helpBtn = document.getElementById('helpBtn');
    var helpModalRoot = document.getElementById('helpModalRoot');
    var helpModal = null;
    var closeHelpBtn = null;
    var cardSearch = document.getElementById('cardSearch');
    var addCardBtn = document.getElementById('addCardBtn');
    var decklistBtn = document.getElementById('decklistBtn');
    var deckModalRoot = document.getElementById('deckModalRoot');
    var deckModal = null;
    var deckText = null;
    var importDeckBtn = null;
    var closeDeckBtn = null;
    var ignoreBasicsChk = null;
    var ignoreSnowChk = null;
    var includeDFCBacksChk = document.getElementById('includeDFCBacksChk');
    var ctxMenu = document.getElementById('ctxMenu');

    /* More refs */
    var themeBtn = null;
    var tuneBtn = null;
    var tuneModal = document.getElementById('tuneModal');
    var tuneTopIn = document.getElementById('tuneTopIn');
    var tuneLeftIn = document.getElementById('tuneLeftIn');
    var saveTuneBtn = document.getElementById('saveTuneBtn');
    var resetTuneBtn = document.getElementById('resetTuneBtn');
    var closeTuneBtn = document.getElementById('closeTuneBtn');
    var tuneCardWIn = document.getElementById('tuneCardWIn');
    var tuneCardHIn = document.getElementById('tuneCardHIn');
    var tuneScaleLock = document.getElementById('tuneScaleLock');

    /* Ratio constants for scaling */
    const BASE_W_IN = 2.5;
    const BASE_H_IN = 3.5;

    /* ===== Environment & storage helpers ===== */
    const ELECTRON_DETECTED = typeof window !== 'undefined'
      && !!(window.process && window.process.versions && window.process.versions.electron);

    const IS_MAC = typeof navigator !== 'undefined'
      && /Mac|iPhone|iPad|iPod/.test((navigator.platform || navigator.userAgent || '').toString());
    const MOD_KEY_LABEL = IS_MAC ? '⌘' : 'Ctrl';

    function isDataUrl(value){
      return typeof value === 'string' && /^data:/i.test(value);
    }

    const IMAGE_EXTENSION_RE = /\.(?:avif|bmp|gif|heic|heif|jfif|jpe?g|png|svg|tif?f|webp)$/i;

    function looksLikeImageFile(file, typeHint){
      if (!file) return false;
      const type = (typeHint || file.type || '').toLowerCase();
      if (type.startsWith('image/')) return true;
      const name = (file.name || '').toLowerCase();
      return !!(name && IMAGE_EXTENSION_RE.test(name));
    }

    function filterImageFiles(list, typeHints){
      const files = Array.from(list || []);
      if (!files.length) return files;
      return files.filter(function(file, idx){
        const hint = Array.isArray(typeHints) ? typeHints[idx] : null;
        return looksLikeImageFile(file, hint);
      });
    }

    function dataUrlToBlob(dataUrl){
      if (typeof dataUrl !== 'string') return null;
      const parts = dataUrl.split(',');
      if (parts.length < 2) return null;
      const match = /^data:([^;]+);base64$/i.exec(parts[0]);
      const mime = match ? match[1] : 'application/octet-stream';
      try{
        const binary = atob(parts[1]);
        const len = binary.length;
        const buffer = new Uint8Array(len);
        for(let i=0;i<len;i++) buffer[i] = binary.charCodeAt(i);
        return new Blob([buffer], { type: mime });
      }catch(_){
        return null;
      }
    }

    function readFileAsDataURL(file){
      return new Promise(function(resolve, reject){
        const reader = new FileReader();
        reader.onerror = function(){ reject(reader.error || new Error('Failed to read file')); };
        reader.onload = function(){ resolve(reader.result); };
        reader.readAsDataURL(file);
      });
    }

    function waitForImageLoad(src){
      return new Promise(function(resolve, reject){
        const img = new Image();
        img.onload = function(){ resolve({ width: img.naturalWidth || 0, height: img.naturalHeight || 0 }); };
        img.onerror = function(){ reject(new Error('Invalid image data')); };
        img.src = src;
      });
    }

    function makeRandomKey(){
      if (typeof crypto !== 'undefined' && crypto.randomUUID){
        return crypto.randomUUID();
      }
      if (typeof crypto !== 'undefined' && crypto.getRandomValues){
        const buf = new Uint8Array(16);
        crypto.getRandomValues(buf);
        return Array.from(buf).map(function(b){ return b.toString(16).padStart(2,'0'); }).join('');
      }
      return Date.now().toString(36) + Math.random().toString(16).slice(2);
    }

    function createIndexedDbStore(){
      const DB_NAME = 'mtgProxyImages';
      const STORE_NAME = 'images';
      let dbPromise = null;
      const urlCache = new Map();

      function openDB(){
        if (dbPromise) return dbPromise;
        if (typeof indexedDB === 'undefined') throw new Error('IndexedDB unavailable');
        dbPromise = new Promise(function(resolve, reject){
          const req = indexedDB.open(DB_NAME, 1);
          req.onerror = function(){ reject(req.error || new Error('IndexedDB open failed')); };
          req.onupgradeneeded = function(){
            const db = req.result;
            if (!db.objectStoreNames.contains(STORE_NAME)){
              db.createObjectStore(STORE_NAME);
            }
          };
          req.onsuccess = function(){ resolve(req.result); };
        });
        return dbPromise;
      }

      function withStore(mode, cb){
        return openDB().then(function(db){
          return new Promise(function(resolve, reject){
            const tx = db.transaction(STORE_NAME, mode);
            tx.onabort = function(){ reject(tx.error || new Error('IndexedDB transaction aborted')); };
            tx.onerror = function(){ reject(tx.error || new Error('IndexedDB transaction failed')); };
            const store = tx.objectStore(STORE_NAME);
            cb(store, resolve, reject);
          });
        });
      }

      function revokeUrl(key){
        const url = urlCache.get(key);
        if (url){
          try{ URL.revokeObjectURL(url); }catch(_){ }
          urlCache.delete(key);
        }
      }

      return {
        ready: openDB().catch(function(err){ console.error('IndexedDB init failed', err); }),
        async storeDataUrl(dataUrl){
          const blob = dataUrlToBlob(dataUrl);
          if (!blob) throw new Error('Invalid image data');
          return this.storeBlob(blob);
        },
        async storeBlob(blob){
          const result = await withStore('readwrite', function(store, resolve, reject){
            const key = makeRandomKey();
            const req = store.put(blob, key);
            req.onsuccess = function(){ resolve({ key: key, mime: blob.type || null }); };
            req.onerror = function(){ reject(req.error || new Error('Failed to store blob')); };
          });
          const url = URL.createObjectURL(blob);
          urlCache.set(result.key, url);
          return { key: result.key, mime: result.mime, url: url };
        },
        async getUrl(key){
          if (urlCache.has(key)) return urlCache.get(key);
          const blob = await this.getBlob(key);
          const url = URL.createObjectURL(blob);
          urlCache.set(key, url);
          return url;
        },
        async getBlob(key){
          const blob = await withStore('readonly', function(store, resolve, reject){
            const req = store.get(key);
            req.onsuccess = function(){ resolve(req.result || null); };
            req.onerror = function(){ reject(req.error || new Error('Failed to read blob')); };
          });
          if (!blob) throw new Error('Missing image data');
          return blob;
        },
        async delete(key){
          revokeUrl(key);
          try{
            await withStore('readwrite', function(store, resolve, reject){
              const req = store.delete(key);
              req.onsuccess = function(){ resolve(); };
              req.onerror = function(){ reject(req.error || new Error('Failed to delete blob')); };
            });
          }catch(err){
            if (!err || err.name !== 'NotFoundError'){
              throw err;
            }
          }
        },
        revokeUrl: revokeUrl
      };
    }

    function createMemoryStore(){
      const storage = new Map();
      const urlCache = new Map();

      function revokeUrl(key){
        const url = urlCache.get(key);
        if (url){
          try{ URL.revokeObjectURL(url); }catch(_){ }
          urlCache.delete(key);
        }
      }

      return {
        ready: Promise.resolve(),
        async storeDataUrl(dataUrl){
          const blob = dataUrlToBlob(dataUrl);
          if (!blob) throw new Error('Invalid image data');
          return this.storeBlob(blob);
        },
        async storeBlob(blob){
          const key = makeRandomKey();
          storage.set(key, blob);
          const url = URL.createObjectURL(blob);
          urlCache.set(key, url);
          return { key: key, mime: blob.type || null, url: url };
        },
        async getUrl(key){
          if (urlCache.has(key)) return urlCache.get(key);
          const blob = storage.get(key);
          if (!blob) throw new Error('Missing image data');
          const url = URL.createObjectURL(blob);
          urlCache.set(key, url);
          return url;
        },
        async getBlob(key){
          const blob = storage.get(key);
          if (!blob) throw new Error('Missing image data');
          return blob;
        },
        async delete(key){
          revokeUrl(key);
          storage.delete(key);
        },
        revokeUrl: revokeUrl
      };
    }

    function createElectronStore(){
      const requireFn = (typeof window !== 'undefined' && typeof window.require === 'function') ? window.require : null;
      if (!requireFn) throw new Error('Electron require not available');

      let electron = null, fs = null, path = null, urlMod = null, fsp = null, BufferCtor = null;
      try{ electron = requireFn('electron'); }catch(_){ }
      try{ fs = requireFn('fs'); }catch(_){ }
      try{ path = requireFn('path'); }catch(_){ }
      try{ urlMod = requireFn('url'); }catch(_){ }
      if (!electron || !fs || !path || !urlMod) throw new Error('Electron modules unavailable');

      fsp = fs.promises;
      if (!fsp){
        try{ fsp = requireFn('fs/promises'); }catch(_){ }
      }
      if (!fsp) throw new Error('fs.promises unavailable');

      BufferCtor = (typeof Buffer !== 'undefined') ? Buffer : null;
      if (!BufferCtor){
        try{ BufferCtor = requireFn('buffer').Buffer; }catch(_){ }
      }
      if (!BufferCtor) throw new Error('Buffer unavailable');

      const { pathToFileURL } = urlMod;
      let app = null;
      if (electron.app && typeof electron.app.getPath === 'function'){ app = electron.app; }
      else if (electron.remote && electron.remote.app){ app = electron.remote.app; }
      else {
        try{
          const remote = requireFn('@electron/remote');
          if (remote && remote.app) app = remote.app;
        }catch(_){ }
      }
      const ipcRenderer = electron.ipcRenderer || null;

      async function resolveUserData(){
        if (app && typeof app.getPath === 'function'){ return app.getPath('userData'); }
        if (ipcRenderer){
          if (typeof ipcRenderer.invoke === 'function'){
            try{ return await ipcRenderer.invoke('mtgProxy:getPath', 'userData'); }catch(_){ }
          }
          if (typeof ipcRenderer.sendSync === 'function'){
            try{ return ipcRenderer.sendSync('mtgProxy:getPath', 'userData'); }catch(_){ }
          }
        }
        throw new Error('Cannot resolve Electron userData path');
      }

      let readyData = null;
      const readyPromise = (async function(){
        const userData = await resolveUserData();
        const dir = path.join(userData, 'images');
        try{
          await fsp.mkdir(dir, { recursive: true });
        }catch(err){
          if (!err || err.code !== 'EEXIST') throw err;
        }
        readyData = { baseDir: dir };
        return readyData;
      })();

      const urlCache = new Map();

      function ensureReady(){
        return readyPromise.then(function(){ return readyData; });
      }

      function toFileUrl(fullPath){
        if (pathToFileURL){
          try{ return pathToFileURL(fullPath).toString(); }catch(_){ }
        }
        const normalized = fullPath.replace(/\\/g, '/');
        return 'file://' + (normalized.startsWith('/') ? normalized : '/' + normalized);
      }

      function guessExt(mime){
        const type = String(mime || '').toLowerCase();
        if (type === 'image/png') return 'png';
        if (type === 'image/jpeg' || type === 'image/jpg') return 'jpg';
        if (type === 'image/gif') return 'gif';
        if (type === 'image/webp') return 'webp';
        if (type === 'image/avif') return 'avif';
        if (type === 'image/bmp') return 'bmp';
        if (type === 'image/tiff') return 'tiff';
        if (type === 'image/svg+xml') return 'svg';
        return 'bin';
      }

      function mimeFromExt(ext){
        const lower = String(ext || '').toLowerCase();
        switch(lower){
          case 'png': return 'image/png';
          case 'jpg':
          case 'jpeg': return 'image/jpeg';
          case 'gif': return 'image/gif';
          case 'webp': return 'image/webp';
          case 'avif': return 'image/avif';
          case 'bmp': return 'image/bmp';
          case 'tif':
          case 'tiff': return 'image/tiff';
          case 'svg': return 'image/svg+xml';
          default: return null;
        }
      }

      async function storeBuffer(buffer, mimeHint){
        const ctx = await ensureReady();
        const ext = guessExt(mimeHint);
        const key = makeRandomKey() + '.' + ext;
        const filePath = path.join(ctx.baseDir, key);
        await fsp.writeFile(filePath, buffer);
        const url = toFileUrl(filePath);
        urlCache.set(key, url);
        const mime = mimeHint || mimeFromExt(ext);
        return { key: key, mime: mime || mimeHint || null, url: url };
      }

      function revokeUrl(key){
        urlCache.delete(key);
      }

      return {
        ready: readyPromise.catch(function(err){ console.error('Electron store init failed', err); throw err; }),
        async storeDataUrl(dataUrl){
          const blob = dataUrlToBlob(dataUrl);
          if (!blob) throw new Error('Invalid image data');
          const array = await blob.arrayBuffer();
          const buffer = BufferCtor.from(array);
          return storeBuffer(buffer, blob.type || 'image/png');
        },
        async storeBlob(blob, mimeHint){
          const array = await blob.arrayBuffer();
          const buffer = BufferCtor.from(array);
          return storeBuffer(buffer, blob.type || mimeHint || 'application/octet-stream');
        },
        async getUrl(key){
          if (urlCache.has(key)) return urlCache.get(key);
          const ctx = await ensureReady();
          const filePath = path.join(ctx.baseDir, key);
          const url = toFileUrl(filePath);
          urlCache.set(key, url);
          return url;
        },
        async getBlob(key, mimeHint){
          const ctx = await ensureReady();
          const filePath = path.join(ctx.baseDir, key);
          const buffer = await fsp.readFile(filePath);
          const ext = path.extname(filePath).replace(/^\./,'');
          const mime = mimeHint || mimeFromExt(ext) || 'application/octet-stream';
          return new Blob([buffer], { type: mime });
        },
        async delete(key){
          revokeUrl(key);
          try{
            const ctx = await ensureReady();
            const filePath = path.join(ctx.baseDir, key);
            await fsp.unlink(filePath);
          }catch(err){
            if (!err || (err.code !== 'ENOENT' && err.code !== 'ENOTDIR')){
              throw err;
            }
          }
        },
        revokeUrl: revokeUrl
      };
    }

    function createImageStore(){
      if (ELECTRON_DETECTED){
        try{
          return createElectronStore();
        }catch(err){
          console.warn('Electron storage unavailable, falling back', err);
        }
      }
      try{
        return createIndexedDbStore();
      }catch(err){
        console.warn('IndexedDB storage unavailable, using in-memory store', err);
      }
      return createMemoryStore();
    }

    const imageStore = createImageStore();
    const imageStoreReady = imageStore && imageStore.ready
      ? imageStore.ready.catch(function(err){ console.error('Image store initialization failed', err); })
      : Promise.resolve();

    function createUrlItem(url){
      return { type: 'url', url: url };
    }

    function createStoredItemFromKey(key, mime){
      return { type: 'stored', key: key, mime: mime || null, resolvedSrc: null };
    }

    async function createStoredItemFromDataUrl(dataUrl){
      const stored = await imageStore.storeDataUrl(dataUrl);
      return {
        type: 'stored',
        key: stored.key,
        mime: stored.mime || null,
        resolvedSrc: stored.url || null
      };
    }

    async function createStoredItemFromBlob(blob, mimeHint){
      const stored = await imageStore.storeBlob(blob, mimeHint);
      return {
        type: 'stored',
        key: stored.key,
        mime: stored.mime || blob.type || mimeHint || null,
        resolvedSrc: stored.url || null
      };
    }

    async function createItemFromSrc(src){
      if (typeof src !== 'string') return null;
      if (isDataUrl(src)){
        return createStoredItemFromDataUrl(src);
      }
      return createUrlItem(src);
    }

    async function cloneItem(item){
      if (!item) return null;
      if (item.type === 'stored' && item.key){
        try{
          const blob = await imageStore.getBlob(item.key, item.mime || null);
          return createStoredItemFromBlob(blob, item.mime || null);
        }catch(err){
          console.error('Failed to clone stored image', err);
          return null;
        }
      }
      if (item.type === 'url' && item.url){
        return createUrlItem(item.url);
      }
      if (item.url){
        return createUrlItem(item.url);
      }
      return null;
    }

    function discardItem(item){
      if (!item || typeof item !== 'object' || item.__disposed) return;
      item.__disposed = true;
      if (item.type === 'stored' && item.key){
        if (typeof imageStore.revokeUrl === 'function'){
          try{ imageStore.revokeUrl(item.key); }catch(_){ }
        }
        if (typeof imageStore.delete === 'function'){
          Promise.resolve(imageStore.delete(item.key)).catch(function(err){
            console.error('Failed to delete stored image', err);
          });
        }
      }
    }

    function disposePageItems(model){
      if (!model || !Array.isArray(model.items)) return;
      model.items.forEach(discardItem);
    }

    /* ===== Modal focus management (trap + restore) ===== */
    let lastFocus = null;
    function trapFocus(m){
      const sel='button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])';
      const f=[...m.querySelectorAll(sel)].filter(el=>!el.disabled && el.offsetParent!==null);
      if(!f.length) return;
      f[0].focus();
      function onKey(e){
        if(e.key!=='Tab') return;
        const i=f.indexOf(document.activeElement);
        if(e.shiftKey && i<=0){ e.preventDefault(); f[f.length-1].focus(); }
        else if(!e.shiftKey && i===f.length-1){ e.preventDefault(); f[0].focus(); }
      }
      m.__trapHandler = onKey;
      m.addEventListener('keydown', onKey);
    }
    function openModal(m){
      ctxHide();
      lastFocus = document.activeElement;
      m.classList.add('open');
      trapFocus(m);
    }
    function closeModal(m){
      m.classList.remove('open');
      if(m.__trapHandler){ m.removeEventListener('keydown', m.__trapHandler); m.__trapHandler=null; }
      if(lastFocus && typeof lastFocus.focus==='function'){ lastFocus.focus(); }
    }

    function setupModalBackdrop(m){
      if (!m || m.__hasBackdrop) return;
      m.addEventListener('click', function(e){
        if (e.target === m){ closeModal(m); }
      });
      m.__hasBackdrop = true;
    }

    function ensureHelpModal(){
      if (helpModal) return helpModal;
      const tpl = document.createElement('template');
      tpl.innerHTML = `
        <div id="helpModal" class="modal">
          <div class="sheet" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
            <h2 id="helpTitle">Help & Hotkeys</h2>

            <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;align-items:start;">
              <div>
                <h3 style="margin:8px 0 4px;font-size:14px;">Hotkeys</h3>
                <ul class="help-list">
                  <li><b>Arrow keys</b> – Move focus between cells</li>
                  <li><b>Ctrl/⌘+← / Ctrl/⌘+→</b> – Prev/Next page (<b>[</b>/<b>]</b> also works)</li>
                  <li><b>Home</b> – First page (Fn+← on Mac)</li>
                  <li><b>End</b> – Last page (Fn+→ on Mac)</li>
                  <li><b>N</b> – Add page</li>
                  <li><b>Shift+Delete/Backspace</b> – Remove current page (confirm)</li>
                  <li><b>Ctrl/⌘+Delete/Backspace</b> – Clear current page</li>
                  <li><b>Ctrl/⌘+Shift+Delete/Backspace</b> – Clear ALL pages</li>
                  <li><b>Alt+Arrows</b> – Reorder focused cell</li>
                  <li><b>D + Drag</b> – Duplicate dragged card to target cell (keeps original)</li>
                  <li><b>Delete/Backspace</b> – Clear focused cell</li>
                  <li><b>1–9</b> – Focus a cell</li>
                  <li><b>Enter</b> in card field – Add card</li>
                  <li><b>P</b> – Print all pages</li>
                  <li><b>G</b> – Toggle guides</li>
                  <li><b>M</b> – Toggle cut marks</li>
                  <li><b>?</b> or <b>H</b> or <b>F1</b> – Open this help</li>
                  <li><b>Esc</b> – Close any open dialog</li>
                </ul>
              </div>

              <div>
                <h3 style="margin:12px 0 4px;font-size:14px;">How it works</h3>
                <ul class="help-list">
                  <li>Drag images anywhere to auto-fill; drag a filled cell to move/swap; drag off the page to delete.</li>
                  <li>To <b>duplicate</b>, hold <b>D</b> while dragging and drop on the target cell.</li>
                  <li>Double-click a cell to replace its image.</li>
                  <li>New pages are created automatically when needed.</li>
                  <li><b>Print</b> prints all pages exact size.</li>
                </ul>

                <h3 style="margin:12px 0 4px;">Image fit: <i>Cover</i> vs <i>Contain</i></h3>
                <ul class="help-list">
                  <li><b>Cover</b> — Scales the image so the cell is completely filled; extra edges may be cropped. Best for edge-to-edge proxies without letterboxing.</li>
                  <li><b>Contain</b> — Fits the whole image inside the cell; nothing is cropped, so you may see empty margins (“letterboxing”).</li>
                </ul>

                <h3 style="margin:12px 0 4px;">Decklist importer</h3>
                <ul class="help-list">
                  <li>Paste one card per line (e.g., <code>4 Lightning Bolt</code>). You can include a set code like <code>[M11]</code> or <code>(M11)</code>.</li>
                  <li>Double-faced cards use the front face (enable “Include DFC back faces” to add the reverse).</li>
                  <li>Use the checkboxes to skip basics and Snow-Covered basics.</li>
                  <li>Images are fetched via Scryfall and placed across pages automatically; unknown cards are skipped.</li>
                </ul>
              </div>
            </div>

            <p class="footnote">* “Through the Omenpaths” cards are currently not compatible.</p>

            <div style="display:flex;gap:8px;align-items:center;">
              <button id="themeBtn" class="secondary" title="Toggle dark mode">🌙</button>
              <button id="tuneBtn" class="secondary" title="Printer tuning (margins/offset)">Advanced</button>
              <div class="right"></div>
              <button id="closeHelpBtn" class="secondary">Close</button>
              <div class="right footnote">© Occam Industries</div>
            </div>
          </div>
        </div>`;
      const modal = tpl.content.firstElementChild;
      (helpModalRoot || document.body).appendChild(modal);
      helpModal = modal;
      closeHelpBtn = helpModal.querySelector('#closeHelpBtn');
      themeBtn = helpModal.querySelector('#themeBtn');
      tuneBtn = helpModal.querySelector('#tuneBtn');
      setupModalBackdrop(helpModal);

      if (closeHelpBtn && !closeHelpBtn.__bound){
        closeHelpBtn.addEventListener('click', function(){ closeModal(helpModal); });
        closeHelpBtn.__bound = true;
      }

      bindThemeButton();
      bindTuneButton();
      setDark(document.documentElement.getAttribute('data-theme') === 'dark');

      return helpModal;
    }

    function ensureDeckModal(){
      if (deckModal) return deckModal;
      const tpl = document.createElement('template');
      tpl.innerHTML = `
        <div id="deckModal" class="modal">
          <div class="sheet" role="dialog" aria-modal="true" aria-labelledby="deckTitle">
            <h2 id="deckTitle">Import decklist (Scryfall)</h2>
            <p style="margin:0;color:#6b7280;font-size:13px">Format: <code>4 Lightning Bolt</code>, one per line. Optional set code with <code>[M11]</code> or <code>(M11)</code>. DFCs use the front face unless you include backs.</p>
            <textarea id="deckText" placeholder="4 Lightning Bolt&#10;2 Snapcaster Mage&#10;1 Sol Ring"></textarea>
            <div style="display:flex; gap:8px; align-items:center;">
              <label class="field" title="Skip Plains/Island/Swamp/Mountain/Forest/Wastes">
                <input id="ignoreBasicsChk" type="checkbox" checked /> Ignore basic lands
              </label>
              <label class="field" title="Also skip Snow-Covered basics">
                <input id="ignoreSnowChk" type="checkbox" checked /> Ignore snow-covered basics
              </label>
              <button id="importDeckBtn">Import</button>
              <div class="right"></div>
              <button id="closeDeckBtn" class="secondary">Close</button>
            </div>
          </div>
        </div>`;
      const modal = tpl.content.firstElementChild;
      (deckModalRoot || document.body).appendChild(modal);
      deckModal = modal;
      deckText = deckModal.querySelector('#deckText');
      importDeckBtn = deckModal.querySelector('#importDeckBtn');
      closeDeckBtn = deckModal.querySelector('#closeDeckBtn');
      ignoreBasicsChk = deckModal.querySelector('#ignoreBasicsChk');
      ignoreSnowChk = deckModal.querySelector('#ignoreSnowChk');
      setupModalBackdrop(deckModal);

      if (closeDeckBtn && !closeDeckBtn.__bound){
        closeDeckBtn.addEventListener('click', function(){ closeModal(deckModal); });
        closeDeckBtn.__bound = true;
      }

      if (deckModal && !deckModal.__wired){
        deckModal.__wired = true;
        const runImport = async () => {
          const text = (deckText && deckText.value ? deckText.value : '').trim();
          if (!text){
            setStatus('Paste a decklist first');
            if (deckText){ deckText.focus(); }
            return;
          }
          if (!importDeckBtn) return;
          importDeckBtn.disabled = true;
          const prevLabel = importDeckBtn.textContent;
          importDeckBtn.textContent = 'Importing…';
          try {
            await importDecklist(text);
            closeModal(deckModal);
            setStatus('Decklist imported');
          } catch (err) {
            console.error(err);
            setStatus('Error importing deck: ' + (err && err.message ? err.message : err));
          } finally {
            importDeckBtn.disabled = false;
            importDeckBtn.textContent = prevLabel;
          }
        };

        if (importDeckBtn){
          importDeckBtn.addEventListener('click', function(e){
            e.preventDefault();
            runImport();
          });
        }

        if (deckText){
          deckText.addEventListener('keydown', function(e){
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter'){
              e.preventDefault();
              runImport();
            }
          });
        }
      }

      return deckModal;
    }

    /* ===== inch/px helpers ===== */
    function measurePxPerIn(){
      var test = document.createElement('div');
      test.style.width = '1in';
      test.style.position='absolute';
      test.style.visibility='hidden';
      document.body.appendChild(test);
      var px = test.getBoundingClientRect().width || 96;
      document.body.removeChild(test);
      return px;
    }
    var PX_PER_IN = measurePxPerIn();
    function getPxPerIn(){ return PX_PER_IN; }
    function refreshPxPerIn(){ var v = measurePxPerIn(); if(Math.abs(v - PX_PER_IN) > 0.5){ PX_PER_IN = v; return true; } return false; }

    function computeFitDims(nw, nh, cw, ch, fit){
      var cellAR = cw / ch; var imgAR = nw / nh; var w, h;
      if(fit === 'cover'){ if(imgAR > cellAR){ h = ch; w = ch * imgAR; } else { w = cw; h = cw / imgAR; } }
      else { if(imgAR > cellAR){ w = cw; h = cw / imgAR; } else { h = ch; w = ch * imgAR; } }
      return { w: w, h: h };
    }

    function cssSizeToPx(val){
      if(!val) return 0;
      var v=String(val).trim();
      if(v.endsWith('vh')){
        var num=parseFloat(v);
        var vh=Math.max(document.documentElement.clientHeight, window.innerHeight||0)/100;
        return num*vh;
      }
      if(v.endsWith('px')) return parseFloat(v);
      var num2=parseFloat(v);
      return isNaN(num2)?0:num2;
    }

    /* Read inches + margins for print math */
    function readCssInches(){
      const cs = getComputedStyle(document.documentElement);
      const px = getPxPerIn();
      const pageW = parseFloat(cs.getPropertyValue('--page-w')) * px;
      const pageH = parseFloat(cs.getPropertyValue('--page-h')) * px;
      const cellW = parseFloat(cs.getPropertyValue('--cell-w')) * px;
      const cellH = parseFloat(cs.getPropertyValue('--cell-h')) * px;

      const gridTopIn = parseFloat(cs.getPropertyValue('--grid-top')) || 0;
      const marginY = gridTopIn * px;

      /* center the grid horizontally */
      const marginX = (pageW - (cellW * cols)) / 2;

      return { pageW, pageH, cellW, cellH, marginX, marginY, px };
    }

    /* ===== Model ===== */
    var pages = []; // {items:Array(9), pageEl, gridEl, cells[], cutOverlayEl}
    var currentPage = 0;
    let ctxTarget = null;

    function createPage(){
      var p = document.createElement('div'); p.className = 'page'; p.setAttribute('role','region'); p.setAttribute('aria-label','Printable page');
      var grid = document.createElement('div'); grid.className = 'grid'; grid.setAttribute('role','grid'); grid.setAttribute('aria-label','9 image grid');
      var cells = [];
      for(var i=0;i<CELLS_PER_PAGE;i++){
        var cell = document.createElement('div'); cell.className = 'cell'; cell.dataset.index = i; cell.tabIndex = 0;
        cell.setAttribute('role','gridcell');
        cell.setAttribute('aria-label','Empty cell ' + (i+1));
        var ph = document.createElement('div'); ph.className = 'placeholder'; ph.textContent = 'Cell ' + (i+1); cell.appendChild(ph);
        grid.appendChild(cell); cells.push(cell);
      }
      var overlay = document.createElement('div'); overlay.className = 'cut-overlay'; p.appendChild(overlay);
      p.appendChild(grid);
      pageWrap.appendChild(p);

      var model = { items: new Array(CELLS_PER_PAGE).fill(null), pageEl: p, gridEl: grid, cells: cells, cutOverlayEl: overlay };
      wireGridEvents(model);
      queueCutOverlay(model);
      return model;
    }

    function getCurrent(){ return pages[currentPage]; }
    function showPage(idx){
      currentPage = Math.max(0, Math.min(idx, pages.length-1));
      pages.forEach((p,i)=>p.pageEl.classList.toggle('current', i===currentPage));
      pageBadge.textContent = 'Page ' + (currentPage+1) + ' / ' + pages.length;
      applyCutOverlay(); doUpdate();
      removePageBtn.disabled = (pages.length <= 1);
      saveState();
    }

    /* ===== Print/Preview mode switching ===== */
    let FORCE_PRINT_MATH = false; // kept for compatibility; not used in measurement anymore
    function refreshCutOverlays(){ pages.forEach(queueCutOverlay); }
    const mqlPrint = window.matchMedia && window.matchMedia('print');
    if (mqlPrint){
      if (mqlPrint.addEventListener){
        mqlPrint.addEventListener('change', e => {
          FORCE_PRINT_MATH = e.matches;
          refreshCutOverlays();
          setTimeout(refreshCutOverlays, 50); // allow layout to settle in preview
        });
      } else if (mqlPrint.addListener){
        mqlPrint.addListener(e => {
          FORCE_PRINT_MATH = e.matches;
          refreshCutOverlays();
          setTimeout(refreshCutOverlays, 50);
        });
      }
    }
    window.addEventListener('beforeprint', () => {
      ctxHide();
      FORCE_PRINT_MATH = true;
      refreshCutOverlays();
      setTimeout(refreshCutOverlays, 50);
    });
    window.addEventListener('afterprint', () => {
      FORCE_PRINT_MATH = false;
      refreshCutOverlays();
    });
    window.addEventListener('pageshow', () => { FORCE_PRINT_MATH = false; refreshCutOverlays(); doUpdate(); });

    function dataTransferHasImage(dt){
      if (!dt) return false;
      const types = dt.types ? Array.from(dt.types) : [];
      if (types.includes('Files')) return true;
      if (types.includes('text/uri-list')) return true;
      if (dt.files && filterImageFiles(dt.files).length) return true;
      if (dt.items && dt.items.length){
        return Array.from(dt.items).some(function(item){
          if (!item) return false;
          if (item.kind === 'file'){ return looksLikeImageFile(item.getAsFile && item.getAsFile(), item.type); }
          if (item.kind === 'string' && item.type === 'text/uri-list') return true;
          return false;
        });
      }
      return false;
    }

    function parseUriList(text){
      if (typeof text !== 'string') return [];
      return text.split(/\r?\n/).map(function(line){ return line.trim(); }).filter(function(line){
        return line && !line.startsWith('#');
      });
    }

    function isProbablyImageUrl(value){
      if (typeof value !== 'string') return false;
      const trimmed = value.trim();
      if (!trimmed) return false;
      if (/^data:image\//i.test(trimmed)) return true;
      if (/^(https?|blob|file):/i.test(trimmed)){ return IMAGE_EXTENSION_RE.test(trimmed.split(/[?#]/)[0] || ''); }
      return false;
    }

    function extractUrlsFromDataTransfer(dt){
      const urls = [];
      if (!dt || typeof dt.getData !== 'function') return urls;
      const uriList = dt.getData('text/uri-list');
      if (uriList){
        urls.push(...parseUriList(uriList));
      }
      if (!urls.length){
        const plain = dt.getData('text/plain');
        if (isProbablyImageUrl(plain)){
          urls.push(plain.trim());
        }
      }
      return urls.filter(isProbablyImageUrl);
    }

    /* ===== Internal drag via PointerEvents ===== */
    let activeDrag = null;   // {srcModel, srcIdx, ghost, lastHover}
    let pendingDrag = null;  // threshold logic before starting
    let duplicateKeyDown = false; // D key

    function setGhostDuplicateStyle(on){
      if(!activeDrag || !activeDrag.ghost) return;
      activeDrag.ghost.style.outline = on ? '2px solid #60a5fa' : '';
      activeDrag.ghost.style.boxShadow = on
        ? '0 8px 24px rgba(37,99,235,.45)'
        : '0 8px 24px rgba(0,0,0,.25)';
    }

    document.addEventListener('keydown', (e)=>{
      if(e.key === 'd' || e.key === 'D'){
        duplicateKeyDown = true; setGhostDuplicateStyle(true);
      }
    });
    document.addEventListener('keyup', (e)=>{
      if(e.key === 'd' || e.key === 'D'){
        duplicateKeyDown = false; setGhostDuplicateStyle(false);
      }
    });

    function resolveModelFromCellEl(el){
      for (const m of pages){
        const j = m.cells.indexOf(el);
        if (j !== -1) return { model: m, index: j };
      }
      return null;
    }

    function makeGhostFromCell(cell){
      const img = cell.querySelector('img');
      const rect = (img || cell).getBoundingClientRect();
      const ghost = document.createElement('img');
      ghost.src = img ? img.src : '';
      ghost.alt = '';
      ghost.style.position='fixed';
      ghost.style.left=rect.left+'px';
      ghost.style.top=rect.top+'px';
      ghost.style.width=rect.width+'px';
      ghost.style.height=rect.height+'px';
      ghost.style.opacity='0.85';
      ghost.style.boxShadow='0 8px 24px rgba(0,0,0,.25)';
      ghost.style.borderRadius='4px';
      ghost.style.pointerEvents='none';
      ghost.style.zIndex='9999';
      return ghost;
    }

    function startGhostDrag(model, idx, startEvt){
      const cell = model.cells[idx];
      if (!model.items[idx]) return;
      cell.classList.add('dragging');
      const ghost = makeGhostFromCell(cell);
      document.body.appendChild(ghost);
      activeDrag = { srcModel: model, srcIdx: idx, ghost, lastHover: null };
      setGhostDuplicateStyle(duplicateKeyDown);
      moveGhostTo(startEvt.clientX, startEvt.clientY, ghost);
      window.addEventListener('pointermove', onDragMove, { passive: false });
      window.addEventListener('pointerup', onDragEnd, { once: true });
      window.addEventListener('pointercancel', onDragCancel, { once: true });
    }

    function moveGhostTo(x,y, ghost){
      const w = ghost.getBoundingClientRect().width;
      const h = ghost.getBoundingClientRect().height;
      ghost.style.left = (x - w/2) + 'px';
      ghost.style.top  = (y - h/2) + 'px';
    }

    function onPointerDownCell(e, model, idx){
      const cell = model.cells[idx];
      ctxHide();
      cell.focus();

      if (e.button !== 0) return;
      if (!model.items[idx]) return;

      e.preventDefault();
      pendingDrag = { model, idx, sx: e.clientX, sy: e.clientY };

      const onMaybeStart = (ev)=>{
        if (!pendingDrag) return;
        const dx = ev.clientX - pendingDrag.sx;
        const dy = ev.clientY - pendingDrag.sy;
        if (Math.hypot(dx,dy) >= 4){
          window.removeEventListener('pointermove', onMaybeStart);
          startGhostDrag(model, idx, ev);
          pendingDrag = null;
        }
      };
      const onUpCancel = ()=>{
        window.removeEventListener('pointermove', onMaybeStart);
        pendingDrag = null;
      };
      window.addEventListener('pointermove', onMaybeStart, { passive: false });
      window.addEventListener('pointerup', onUpCancel, { once: true });
      window.addEventListener('pointercancel', onUpCancel, { once: true });
    }

    function onDragMove(e){
      if (!activeDrag) return;
      e.preventDefault();
      const el = document.elementFromPoint(e.clientX, e.clientY);
      const hover = el && el.closest && el.closest('.cell');
      moveGhostTo(e.clientX, e.clientY, activeDrag.ghost);
      if (activeDrag.lastHover && activeDrag.lastHover !== hover){
        activeDrag.lastHover.classList.remove('drop-target');
      }
      if (hover) hover.classList.add('drop-target');
      activeDrag.lastHover = hover || null;
    }

    function clearHover(){
      if (activeDrag && activeDrag.lastHover){
        activeDrag.lastHover.classList.remove('drop-target');
        activeDrag.lastHover = null;
      }
    }

    function finishDragCleanup(){
      if (!activeDrag) return;
      const srcCell = activeDrag.srcModel.cells[activeDrag.srcIdx];
      srcCell.classList.remove('dragging');
      clearHover();
      if (activeDrag.ghost && activeDrag.ghost.parentNode) activeDrag.ghost.parentNode.removeChild(activeDrag.ghost);
      activeDrag = null;
      duplicateKeyDown = false;
      setGhostDuplicateStyle(false);
    }

    async function onDragEnd(e){
      if (!activeDrag) return;

      try{
        let hover = activeDrag.lastHover;
        if (!hover) {
          const at = document.elementFromPoint(e.clientX, e.clientY);
          hover = at && at.closest ? at.closest('.cell') : null;
        }

        if (hover){
          const dst = resolveModelFromCellEl(hover);
          if (dst) {
            if (duplicateKeyDown){
              const a = activeDrag.srcModel.items[activeDrag.srcIdx];
              if (a){
                try{
                  const clone = await cloneItem(a);
                  if (clone){
                    const prev = dst.model.items[dst.index];
                    if (prev && prev !== clone){ discardItem(prev); }
                    dst.model.items[dst.index] = clone;
                    renderCell(dst.model, dst.index);
                    saveState();
                  }
                }catch(err){
                  console.error('Failed to duplicate image', err);
                }
              }
            } else {
              handleInternalDrop(activeDrag.srcModel, activeDrag.srcIdx, dst.model, dst.index);
            }
          }
        } else {
          if (!duplicateKeyDown){
            const m = activeDrag.srcModel;
            const i = activeDrag.srcIdx;
            if (m.items[i]){
              discardItem(m.items[i]);
              m.items[i] = null;
              renderCell(m, i);
              saveState();
            }
          }
        }
      } finally {
        finishDragCleanup();
        window.removeEventListener('pointermove', onDragMove);
      }
    }

    function onDragCancel(){
      finishDragCleanup();
      window.removeEventListener('pointermove', onDragMove);
    }

    /* ===== External file DnD (native) ===== */
    function wireGridEvents(model){
      model.cells.forEach((cell, idx) => {
        cell.addEventListener('pointerdown', (e)=>onPointerDownCell(e, model, idx));
        cell.addEventListener('click', ()=> cell.focus());

        cell.addEventListener('dragover', (e) => {
          const dt = e.dataTransfer;
          if (!dataTransferHasImage(dt)) return;
          e.preventDefault();
          e.stopPropagation();
          cell.classList.add('drop-target');
          if (dt) dt.dropEffect = 'copy';
        });
        cell.addEventListener('dragleave', (e) => {
          e.stopPropagation();
          cell.classList.remove('drop-target');
        });
        cell.addEventListener('drop', async (e) => {
          const dt = e.dataTransfer;
          if (!dataTransferHasImage(dt)) return;
          e.preventDefault();
          e.stopPropagation();
          cell.classList.remove('drop-target');
          const pageIdx = pages.indexOf(model);
          try{
            let placed = 0;
            const files = dt ? filterImageFiles(dt.files) : [];
            if (files.length){
              placed = await handleFilesIntoCell(model, idx, files);
            } else {
              const urls = extractUrlsFromDataTransfer(dt);
              if (urls.length){
                placed = await handleImageUrls(urls, {
                  preferredSlot: pageIdx === -1 ? null : { page: pageIdx, index: idx },
                  startPage: pageIdx,
                  allowOverwrite: true
                });
              }
            }
            if (placed > 0){
              setStatus(placed === 1 ? 'Added image from drop' : `Added ${placed} images from drop`);
            } else {
              setStatus('No images found in dropped data');
            }
          }catch(err){
            console.error('Failed to handle dropped images', err);
            setStatus('Failed to add dropped images');
          }
        });

        cell.addEventListener('dblclick', function(){
          targetIndexForFile = {page: pages.indexOf(model), index: idx};
          fileInput.click();
        });
      });

      ['dragenter','dragover'].forEach(function(evt){
        model.gridEl.addEventListener(evt, function(e){
          const dt = e.dataTransfer;
          if (!dataTransferHasImage(dt)) return;
          const p=model.pageEl;
          p.classList.add('dragover');
          e.preventDefault();
          e.stopPropagation();
          if (dt) dt.dropEffect = 'copy';
        });
      });
      ['dragleave','drop'].forEach(function(evt){
        model.gridEl.addEventListener(evt, async function(e){
          const dt = e.dataTransfer;
          if (!dataTransferHasImage(dt)) return;
          const p=model.pageEl;
          if(evt==='drop'){
            e.preventDefault();
            e.stopPropagation();
            const pageIdx = pages.indexOf(model);
            try{
              const files = dt ? filterImageFiles(dt.files) : [];
              let placed = 0;
              if (files.length){
                placed = await handleFiles(files, { startPage: pageIdx });
              } else {
                const urls = extractUrlsFromDataTransfer(dt);
                if (urls.length){
                  placed = await handleImageUrls(urls, { startPage: pageIdx });
                }
              }
              if (placed > 0){
                setStatus(placed === 1 ? 'Added image from drop' : `Added ${placed} images from drop`);
              } else {
                setStatus('No images found in dropped data');
              }
            }catch(err){
              console.error('Failed to add dropped images', err);
              setStatus('Failed to add dropped images');
            }
          } else {
            e.preventDefault();
            e.stopPropagation();
          }
          p.classList.remove('dragover');
        });
      });
    }

    // Move / swap logic
    function handleInternalDrop(srcModel, srcIdx, dstModel, dstIdx){
      if (!srcModel || !dstModel) return;
      if (srcModel === dstModel && srcIdx === dstIdx) return;

      const a = srcModel.items[srcIdx];
      const b = dstModel.items[dstIdx];
      if (!a) return;

      if (b) {
        srcModel.items[srcIdx] = b;
        dstModel.items[dstIdx] = a;
      } else {
        srcModel.items[srcIdx] = null;
        dstModel.items[dstIdx] = a;
      }

      renderCell(srcModel, srcIdx);
      renderCell(dstModel, dstIdx);
      saveState();
    }

    /* ===== Rendering ===== */
    function fitImage(el){
      var fit = fitModeSelect.value;
      var nw = el.naturalWidth||el.width||1; var nh = el.naturalHeight||el.height||1;
      const { cellW, cellH } = readCssInches();
      var d = computeFitDims(nw, nh, cellW, cellH, fit);
      el.style.width = d.w+'px';
      el.style.height = d.h+'px';
    }

    async function resolveItemSrc(item){
      if (!item) return null;
      if (item.type === 'stored' && item.key){
        if (item.resolvedSrc) return item.resolvedSrc;
        const url = await imageStore.getUrl(item.key, item.mime || null);
        item.resolvedSrc = url;
        return url;
      }
      if (item.type === 'url' && item.url){
        return item.url;
      }
      if (item.url){
        return item.url;
      }
      return null;
    }

    function renderCell(model, i){
      const cell = model.cells[i];
      cell.innerHTML='';
      const data = model.items[i];

      if(!data){
        cell.setAttribute('aria-label','Empty cell ' + (i+1));
        const ph=document.createElement('div'); ph.className='placeholder'; ph.textContent='Cell ' + (i+1);
        cell.appendChild(ph);
        return;
      }

      cell.setAttribute('aria-label','Occupied cell ' + (i+1));
      const el=document.createElement('img');
      el.alt = '';
      el.draggable = false;
      el.addEventListener('dragstart', e => e.preventDefault());
      const token = {};
      data.__renderToken = token;
      el.onload = function(){
        if (data.__renderToken !== token) return;
        fitImage(el);
      };
      cell.appendChild(el);

      Promise.resolve(resolveItemSrc(data)).then(function(src){
        if (!src){
          throw new Error('Missing image source');
        }
        if (data.__renderToken !== token) return;
        el.src = src;
      }).catch(function(err){
        console.error('Failed to render image', err);
        if (data.__renderToken !== token) return;
        discardItem(data);
        model.items[i] = null;
        renderCell(model, i);
        saveState();
      });
    }

    function renderGrid(model){ for(var i=0;i<CELLS_PER_PAGE;i++) renderCell(model,i); }

    /* ===== Guides & cuts ===== */
    toggleGuides.addEventListener('change', function(){
      var show = toggleGuides.checked;
      document.documentElement.style.setProperty('--guide-color', show ? 'rgba(0,0,0,.25)' : 'transparent');
    });

    // NEW: Always measure actual DOM positions (screen & print) for perfect alignment
    function renderCutOverlay(model){
      const overlay = model.cutOverlayEl;

      // Measure overlay box (page) and cells
      const ovb = overlay.getBoundingClientRect();
      const W = ovb.width, H = ovb.height;

      if (!W || !H){
        overlay.innerHTML = `<svg viewBox="0 0 1 1"></svg>`;
        return;
      }

      const firstRow = model.cells.slice(0, cols);
      const firstCol = model.cells.filter((_, i) => i % cols === 0);
      if (!firstRow.length || !firstCol.length) {
        overlay.innerHTML = `<svg viewBox="0 0 ${W} ${H}"></svg>`;
        return;
      }

      // Grid bounds (relative to overlay)
      const left   = firstRow[0].getBoundingClientRect().left  - ovb.left;
      const right  = firstRow[firstRow.length-1].getBoundingClientRect().right - ovb.left;
      const top    = firstCol[0].getBoundingClientRect().top   - ovb.top;
      const bottom = firstCol[firstCol.length-1].getBoundingClientRect().bottom - ovb.top;

      const cw = (right - left) / cols;
      const ch = (bottom - top) / rows;

      // Lines at every cell boundary, including outer edges
      const xs = [];
      for (let i = 0; i <= cols; i++) xs.push(left + i * cw);
      const ys = [];
      for (let j = 0; j <= rows; j++) ys.push(top + j * ch);

      overlay.innerHTML =
        `<svg viewBox="0 0 ${W} ${H}" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none" shape-rendering="crispEdges">
           <g stroke="#9ca3af" stroke-width="1" fill="none">
             ${xs.map(x=>`<line x1="${x}" y1="0" x2="${x}" y2="${H}"/>`).join('')}
             ${ys.map(y=>`<line x1="0" y1="${y}" x2="${W}" y2="${y}"/>`).join('')}
           </g>
         </svg>`;
    }

    function queueCutOverlay(model){
      if (!model) return;
      requestAnimationFrame(() => requestAnimationFrame(() => renderCutOverlay(model)));
    }

    function applyCutOverlay(){
      pages.forEach(m=>m.pageEl.classList.toggle('show-cuts', toggleCutMarks.checked));
      pages.forEach(queueCutOverlay); // rebuild when toggled
    }
    toggleCutMarks.addEventListener('change', applyCutOverlay);

    // Rebuild overlays on layout changes
    function doUpdate(){
      refreshPxPerIn();
      const cur = getCurrent();
      if (cur) cur.gridEl.querySelectorAll('img').forEach(img=>fitImage(img));
      updatePreviewScale();
      if (cur) { queueCutOverlay(cur); }
    }

    /* ===== Files & placement ===== */
    var targetIndexForFile = null; // {page,index}
    function placeImage(model, idx, item){
      if (!model || !model.items) return;
      const prev = model.items[idx];
      if (prev && prev !== item){
        discardItem(prev);
      }
      model.items[idx] = item;
      renderCell(model, idx);
      saveState();
    }

    fileInput.addEventListener('change', function(e){
      const selected = filterImageFiles(e.target.files || []);
      const totalSelected = (e.target.files && e.target.files.length) || 0;
      const reset = () => { fileInput.value=''; };

      if(targetIndexForFile){
        const target = targetIndexForFile;
        targetIndexForFile = null;
        if(selected.length){
          assignFileToIndex(selected[0], target.page, target.index)
            .then(function(count){
              setStatus(count ? 'Replaced image' : 'No image replaced');
            })
            .catch(function(err){
              console.error('Failed to replace image', err);
              setStatus('Failed to replace image');
            })
            .finally(reset);
        } else {
          setStatus(totalSelected ? 'Selected file was not an image' : 'No image selected');
          reset();
        }
        return;
      }

      if(!selected.length){
        if(totalSelected){ setStatus('Selected files were not images'); }
        reset();
        return;
      }

      handleFiles(selected)
        .then(function(count){
          if(count){
            setStatus(count === 1 ? 'Added 1 image' : `Added ${count} images`);
          } else {
            setStatus('No images added');
          }
        })
        .catch(function(err){
          console.error('Failed to add images', err);
          setStatus('Failed to add images');
        })
        .finally(reset);
    });

    ['dragenter','dragover'].forEach(function(evt){
      pageWrap.addEventListener(evt, function(e){
        const dt = e.dataTransfer;
        if (!dataTransferHasImage(dt)) return;
        const current = getCurrent();
        if (!current || !current.pageEl) return;
        current.pageEl.classList.add('dragover');
        e.preventDefault();
        e.stopPropagation();
        if (dt) dt.dropEffect = 'copy';
      });
    });
    ['dragleave','drop'].forEach(function(evt){
      pageWrap.addEventListener(evt, async function(e){
        const dt = e.dataTransfer;
        if (!dataTransferHasImage(dt)) return;
        const current = getCurrent();
        if (!current || !current.pageEl) return;
        const pageIdx = pages.indexOf(current);
        if(evt==='drop'){
          e.preventDefault();
          e.stopPropagation();
          try{
            const files = dt ? filterImageFiles(dt.files) : [];
            let placed = 0;
            if (files.length){
              placed = await handleFiles(files, { startPage: pageIdx });
            } else {
              const urls = extractUrlsFromDataTransfer(dt);
              if (urls.length){
                placed = await handleImageUrls(urls, { startPage: pageIdx });
              }
            }
            if (placed > 0){
              setStatus(placed === 1 ? 'Added image from drop' : `Added ${placed} images from drop`);
            } else {
              setStatus('No images found in dropped data');
            }
          }catch(err){
            console.error('Failed to add dropped images', err);
            setStatus('Failed to add dropped images');
          }
        } else {
          e.preventDefault();
          e.stopPropagation();
        }
        current.pageEl.classList.remove('dragover');
      });
    });

    function collectImageFilesFromClipboardData(cd){
      const files = [];
      if(!cd) return files;
      if(cd.files && cd.files.length){
        files.push(...filterImageFiles(cd.files));
      }
      if(cd.items && cd.items.length){
        Array.from(cd.items).forEach(function(item){
          if(!item || item.kind !== 'file') return;
          const file = item.getAsFile ? item.getAsFile() : null;
          if(file && looksLikeImageFile(file, item.type)){
            files.push(file);
          }
        });
      }
      return files;
    }

    const CLIPBOARD_UNAVAILABLE_MSG = 'Clipboard image actions are not supported in this browser';

    function clipboardCanWriteImage(){
      return typeof navigator !== 'undefined'
        && navigator.clipboard
        && typeof navigator.clipboard.write === 'function'
        && typeof ClipboardItem !== 'undefined';
    }

    function clipboardCanReadImage(){
      return typeof navigator !== 'undefined'
        && navigator.clipboard
        && typeof navigator.clipboard.read === 'function';
    }

    async function copyCellImage(model, index){
      const item = model && model.items ? model.items[index] : null;
      if(!item){
        setStatus('Cell is empty');
        return false;
      }
      if(!clipboardCanWriteImage()){
        setStatus(CLIPBOARD_UNAVAILABLE_MSG);
        return false;
      }
      try{
        let blob = null;
        if (item.type === 'stored' && item.key){
          blob = await imageStore.getBlob(item.key, item.mime || null);
        } else {
          const src = await resolveItemSrc(item);
          if (!src){
            setStatus('Unable to resolve image source');
            return false;
          }
          if (isDataUrl(src)){
            const dataBlob = dataUrlToBlob(src);
            if (!dataBlob){
              setStatus('Unable to access image data');
              return false;
            }
            blob = dataBlob;
          } else {
            const response = await fetch(src, { mode: 'cors' }).catch(function(err){ throw err; });
            if (!response || !response.ok){
              throw new Error('Unable to fetch image data');
            }
            blob = await response.blob();
          }
        }
        if(!blob){
          setStatus('Unable to access image data');
          return false;
        }
        const mime = blob.type && blob.type.startsWith('image/') ? blob.type : (item.mime || 'image/png');
        const clipItem = new ClipboardItem({ [mime]: blob });
        await navigator.clipboard.write([clipItem]);
        setStatus('Copied image to clipboard');
        return true;
      }catch(err){
        console.error('Failed to copy image', err);
        setStatus('Failed to copy image: ' + (err && err.message ? err.message : err));
        return false;
      }
    }

    async function readClipboardImageFiles(){
      if(!clipboardCanReadImage()) return [];
      const results = [];
      const items = await navigator.clipboard.read();
      for (const item of items){
        if(!item || !item.types) continue;
        const type = item.types.find(function(t){ return /^image\//i.test(t); });
        if(!type) continue;
        try{
          const blob = await item.getType(type);
          const mime = (blob && blob.type) ? blob.type : type;
          if(typeof File === 'function'){
            const ext = (mime && mime.split('/')[1]) ? mime.split('/')[1].split('+')[0] : 'png';
            const name = `clipboard-${Date.now()}-${results.length}.${ext}`;
            results.push(new File([blob], name, { type: mime }));
          } else {
            blob.name = blob.name || `clipboard-${results.length}`;
            results.push(blob);
          }
        }catch(err){
          console.error('Failed to read clipboard image item', err);
        }
      }
      return results;
    }

    function preferredSlotForPage(pageIdx){
      if(typeof pageIdx !== 'number' || pageIdx < 0 || pageIdx >= pages.length) return null;
      const model = pages[pageIdx];
      if(!model || !model.items) return null;
      const empty = model.items.findIndex(function(item){ return !item; });
      return empty !== -1 ? { page: pageIdx, index: empty } : null;
    }

    async function pasteImageFromClipboard(target){
      if(!clipboardCanReadImage()){
        setStatus(CLIPBOARD_UNAVAILABLE_MSG);
        return false;
      }
      try{
        const files = await readClipboardImageFiles();
        if(!files.length){
          setStatus('Clipboard does not contain image data');
          return false;
        }
        let placed = 0;
        if(target && target.model && typeof target.index === 'number'){
          placed = await handleFilesIntoCell(target.model, target.index, files);
        } else if(target && typeof target.pageIndex === 'number'){
          const preferred = preferredSlotForPage(target.pageIndex);
          placed = await handleFiles(files, {
            startPage: target.pageIndex,
            preferredSlot: preferred,
            allowOverwrite: !!target.allowOverwrite
          });
        } else {
          placed = await handleFiles(files);
        }
        if(placed > 0){
          setStatus(placed === 1 ? 'Pasted image from clipboard' : `Pasted ${placed} images from clipboard`);
          return true;
        }
        setStatus('Clipboard does not contain image data');
        return false;
      }catch(err){
        console.error('Failed to paste image', err);
        setStatus('Failed to paste image: ' + (err && err.message ? err.message : err));
        return false;
      }
    }

    document.addEventListener('paste', async function(e){
      const active = document.activeElement;
      if(active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;

      const clipboardData = e.clipboardData || window.clipboardData || null;
      const focusedCell = document.activeElement && document.activeElement.closest ? document.activeElement.closest('.cell') : null;
      const resolved = focusedCell ? resolveModelFromCellEl(focusedCell) : null;
      const resolvedPageIdx = resolved ? pages.indexOf(resolved.model) : -1;

      if(clipboardData){
        const files = collectImageFilesFromClipboardData(clipboardData);
        if(files.length){
          e.preventDefault();
          let placed = 0;
          if(resolved && resolved.model){
            placed = await handleFilesIntoCell(resolved.model, resolved.index, files);
          } else {
            placed = await handleFiles(files);
          }
          setStatus(placed ? (placed === 1 ? 'Pasted image from clipboard' : `Pasted ${placed} images from clipboard`) : 'Clipboard does not contain image data');
          return;
        }

        let urls = clipboardData.getData ? parseUriList(clipboardData.getData('text/uri-list')) : [];
        if(!urls.length && clipboardData.getData){
          const plain = clipboardData.getData('text/plain');
          if(isProbablyImageUrl(plain)){
            urls = [plain.trim()];
          }
        }
        if(urls.length){
          e.preventDefault();
          let placed = 0;
          if(resolved && resolved.model){
            placed = await handleImageUrls(urls, {
              preferredSlot: resolvedPageIdx === -1 ? null : { page: resolvedPageIdx, index: resolved.index },
              startPage: resolvedPageIdx,
              allowOverwrite: true
            });
          } else {
            placed = await handleImageUrls(urls, { startPage: currentPage });
          }
          setStatus(placed ? (placed === 1 ? 'Pasted image from clipboard' : `Pasted ${placed} images from clipboard`) : 'Clipboard does not contain image data');
          return;
        }
      }

      if(clipboardCanReadImage()){
        e.preventDefault();
        const target = resolved && resolved.model
          ? { model: resolved.model, index: resolved.index, pageIndex: resolvedPageIdx, allowOverwrite: true }
          : { pageIndex: currentPage };
        await pasteImageFromClipboard(target);
        return;
      }

      if(clipboardData){
        setStatus('Clipboard does not contain image data');
      } else {
        setStatus(CLIPBOARD_UNAVAILABLE_MSG);
      }
    });

    const IMAGE_FILE_BATCH_SIZE = 16;

    function readFileAsDataURL(file){
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error || new Error('Failed to read file.'));
        reader.readAsDataURL(file);
      });
    }

    function ensureImageLoaded(src){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve();
        img.onerror = () => reject(new Error('Image failed to load.'));
        img.src = src;
      });
    }

    async function processImageFilesInBatches(files, handler){
      if(!files.length) return;
      const idleScheduler = (typeof requestIdleCallback === 'function') ? requestIdleCallback : setTimeout;
      for(let start = 0; start < files.length; start += IMAGE_FILE_BATCH_SIZE){
        const batch = files.slice(start, start + IMAGE_FILE_BATCH_SIZE);
        for(const file of batch){
          try{
            const dataPromise = readFileAsDataURL(file);
            let decodedWithBitmap = false;
            if(typeof createImageBitmap === 'function'){
              try{
                const bitmap = await createImageBitmap(file);
                decodedWithBitmap = true;
                if(bitmap && typeof bitmap.close === 'function'){
                  bitmap.close();
                }
              }catch(err){
                console.warn('createImageBitmap failed; falling back to Image()', err);
              }
            }
            const dataUrl = await dataPromise;
            if(!decodedWithBitmap){
              await ensureImageLoaded(dataUrl);
            }
            await handler(file, dataUrl);
          }catch(err){
            console.error('Failed to process image file', err);
          }
        }
        await new Promise(r => idleScheduler === setTimeout ? idleScheduler(r, 0) : idleScheduler(r, { timeout: 0 }));
      }
    }

    async function assignFileToIndex(file, pageIdx, cellIdx){
      if(!looksLikeImageFile(file)) return 0;
      const model = pages[pageIdx];
      if(!model) return 0;
      return handleFilesIntoCell(model, cellIdx, [file]);
    }

    function nextEmptySlot(startPage){ if(startPage==null) startPage=0; for(var p=startPage;p<pages.length;p++){ var model=pages[p]; var idx=model.items.findIndex(x=>x==null); if(idx!==-1) return {page:p, index: idx}; } return null; }

    function nextEmptySlotFrom(start){
      var p = start && typeof start.page==='number' ? start.page : 0;
      var i = start && typeof start.index==='number' ? start.index : 0;
      for(var page=p; page<pages.length; page++){
        var m = pages[page];
        for(var idx=(page===p?i:0); idx<CELLS_PER_PAGE; idx++){
          if(m.items[idx]==null) return {page: page, index: idx};
        }
      }
      return null;
    }

    function ensurePageForAppend(){
      var slot = nextEmptySlot(0);
      if(slot) return slot;
      var m=createPage(); pages.push(m); showPage(pages.length-1); saveState();
      return {page: pages.length-1, index: 0};
    }

    async function handleFilesIntoCell(model, targetIdx, fileList){
      const files = filterImageFiles(fileList);
      if(!files.length) return 0;
      const pageIdx = pages.indexOf(model);
      if(pageIdx === -1) return 0;
      let placed = 0;
      let pos = {page: pageIdx, index: targetIdx};
      await processImageFilesInBatches(files, async (_, dataUrl) => {
        try{
          const item = await createStoredItemFromDataUrl(dataUrl);
          if(!item) return;
          const m = pages[pos.page];
          if(!m) return;
          placeImage(m, pos.index, item);
          placed++;
          const next = nextEmptySlotFrom({page: pos.page, index: pos.index+1}) || ensurePageForAppend();
          pos = next;
        }catch(err){
          console.error('Failed to store dropped image', err);
        }
      });
      return placed;
    }

    async function handleFiles(fileList, opts){
      const files = filterImageFiles(fileList);
      if(!files.length) return 0;

      var preferred = opts && opts.preferredSlot ? opts.preferredSlot : null;
      const allowOverwrite = !!(opts && opts.allowOverwrite);
      var startPage = (opts && typeof opts.startPage === 'number') ? opts.startPage : currentPage;
      if(!pages.length){
        startPage = 0;
      } else {
        if(startPage < 0) startPage = 0;
        if(startPage >= pages.length) startPage = pages.length - 1;
      }

      if(preferred){
        var hasModel = pages[preferred.page] && pages[preferred.page].items;
        var isValid = hasModel && (pages[preferred.page].items[preferred.index] == null || allowOverwrite);
        if(!isValid){ preferred = null; }
      }

      var usingPreferredFirst = !!preferred;
      var pos = preferred || nextEmptySlot(startPage) || ensurePageForAppend();

      let placed = 0;
      await processImageFilesInBatches(files, async (_, dataUrl) => {
        try{
          const item = await createStoredItemFromDataUrl(dataUrl);
          if(!item) return;
          const target = pos || nextEmptySlot(startPage) || ensurePageForAppend();
          const m = pages[target.page];
          if(!m) return;
          placeImage(m, target.index, item);
          placed++;

          if(usingPreferredFirst){
            usingPreferredFirst = false;
            pos = nextEmptySlot(target.page) || ensurePageForAppend();
          } else {
            var startFrom = (target.index + 1 >= CELLS_PER_PAGE) ? target.page + 1 : target.page;
            pos = nextEmptySlot(startFrom) || ensurePageForAppend();
          }
        }catch(err){
          console.error('Failed to store image file', err);
        }
      });
      return placed;
    }

    async function handleImageUrls(urlList, opts){
      const urls = Array.from(urlList || []).map(function(u){
        return typeof u === 'string' ? u.trim() : '';
      }).filter(isProbablyImageUrl);
      if(!urls.length) return 0;

      let startPage = (opts && typeof opts.startPage === 'number') ? opts.startPage : currentPage;
      if(!pages.length){
        startPage = 0;
      } else {
        if(startPage < 0) startPage = 0;
        if(startPage >= pages.length) startPage = pages.length - 1;
      }

      let preferred = opts && opts.preferredSlot ? opts.preferredSlot : null;
      const allowOverwrite = !!(opts && opts.allowOverwrite);
      if(preferred){
        const hasModel = pages[preferred.page] && pages[preferred.page].items;
        const isValid = hasModel && (pages[preferred.page].items[preferred.index] == null || allowOverwrite);
        if(!isValid){ preferred = null; }
      }

      let usingPreferredFirst = !!preferred;
      let pos = preferred || nextEmptySlot(startPage) || ensurePageForAppend();
      let placed = 0;

      for (const src of urls){
        if(!src) continue;
        try{
          const item = await createItemFromSrc(src);
          if(!item) continue;
          const target = pos || nextEmptySlot(startPage) || ensurePageForAppend();
          const m = pages[target.page];
          if(!m) continue;
          placeImage(m, target.index, item);
          placed++;

          if(usingPreferredFirst){
            usingPreferredFirst = false;
            pos = nextEmptySlot(target.page) || ensurePageForAppend();
          } else {
            const startFrom = (target.index + 1 >= CELLS_PER_PAGE) ? target.page + 1 : target.page;
            pos = nextEmptySlot(startFrom) || ensurePageForAppend();
          }
        }catch(err){
          console.error('Failed to handle image URL', err);
        }
      }

      return placed;
    }

    /* ===== Pager & Clear helpers ===== */
    function addPage(){ pages.push(createPage()); showPage(pages.length-1); saveState(); }

    function removeCurrentPage(forceConfirm){
      if(pages.length <= 1){ alert('Cannot remove the last page.'); return false; }
      var m = getCurrent();
      var hasContent = m.items.some(Boolean);
      if (forceConfirm){
        if(!confirm('Remove the current page? This cannot be undone.')) return false;
      } else if(hasContent){
        if(!confirm('This page has images. Remove it?')) return false;
      }
      var idx = currentPage;
      disposePageItems(m);
      pageWrap.removeChild(m.pageEl);
      pages.splice(idx, 1);
      showPage(Math.min(idx, pages.length - 1));
      saveState();
      return true;
    }

    function clearCurrentPage(){
      var m=getCurrent();
      disposePageItems(m);
      m.items = new Array(CELLS_PER_PAGE).fill(null);
      renderGrid(m);
      saveState();
      setStatus('Cleared current page');
    }

    function clearAllPages(forceConfirm){
      const hasAny = pages.some(p => p.items.some(Boolean));
      const msg = 'Delete ALL pages and images? This cannot be undone.';
      if (forceConfirm || hasAny){
        if(!confirm(msg)) return;
      }
      pages.forEach(disposePageItems);
      try{ localStorage.removeItem('mtgProxyPages'); }catch(_){}
      pageWrap.innerHTML = '';
      pages.length = 0;
      const m = createPage();
      pages.push(m);
      renderGrid(m);
      showPage(0);
      setStatus('Cleared ALL pages');
    }

    prevPageBtn.addEventListener('click', function(){ showPage(Math.max(0, currentPage-1)); });
    nextPageBtn.addEventListener('click', function(){ showPage(Math.min(pages.length-1, currentPage+1)); });
    addPageBtn.addEventListener('click', addPage);
    removePageBtn.addEventListener('click', function(){ removeCurrentPage(false); });

    clearBtn.addEventListener('click', clearCurrentPage);
    clearAllBtn.addEventListener('click', function(){ clearAllPages(true); });

    printBtn.addEventListener('click', function(){
      ctxHide();
      pages.forEach(p => p.pageEl.offsetHeight);
      window.print();
    });

    /* ===== Preview sizing (reads CSS page vars) ===== */
    function updatePreviewScale(){
      var header=document.querySelector('header');
      var controls=document.querySelector('.controls');
      var app=document.querySelector('.app');
      var headerH=header?header.getBoundingClientRect().height:0;
      var controlsH=controls?controls.getBoundingClientRect().height:0;
      var rowGap=app?parseFloat(getComputedStyle(app).rowGap)||0:0;
      var appGaps=rowGap*2;
      var bottomGapVar=getComputedStyle(document.documentElement).getPropertyValue('--preview-bottom-gap')||'5vh';
      var bottomGapPx=cssSizeToPx(bottomGapVar);
      var availH=Math.max(0, window.innerHeight-headerH-controlsH-appGaps-bottomGapPx);
      var availW=Math.max(0, window.innerWidth);
      var pxPerIn = getPxPerIn();

      const cs = getComputedStyle(document.documentElement);
      const pageWpx = parseFloat(cs.getPropertyValue('--page-w')) * pxPerIn;
      const pageHpx = parseFloat(cs.getPropertyValue('--page-h')) * pxPerIn;

      var scale=Math.min(availW/pageWpx, availH/pageHpx, 1);
      document.documentElement.style.setProperty('--preview-scale', String(scale>0?scale:1));
    }

    function debounce(fn, ms){ var t; return function(){ clearTimeout(t); t=setTimeout(fn, ms); }; }
    const debouncedUpdate = debounce(doUpdate, 100);

    window.addEventListener('resize', debouncedUpdate);
    window.addEventListener('orientationchange', debouncedUpdate);
    document.addEventListener('fullscreenchange', debouncedUpdate);
    document.addEventListener('visibilitychange', function(){ if(!document.hidden) debouncedUpdate(); });
    const ro = new ResizeObserver(()=>debouncedUpdate());
    ro.observe(document.documentElement);

    /* ===== Keyboard A11y & Hotkeys ===== */
    document.addEventListener('keydown', function(e){
      const tag = (e.target && e.target.tagName) || '';
      const typing = /INPUT|TEXTAREA|SELECT/.test(tag);
      if(typing){
        if(e.key==='Enter' && e.target===cardSearch){ e.preventDefault(); addCardBtn.click(); }
        return;
      }

      if(e.key==='F1' || e.key==='?' || e.key==='h' || e.key==='H'){
        e.preventDefault();
        openModal(ensureHelpModal());
        return;
      }

      if(e.key==='p' || e.key==='P'){ e.preventDefault(); printBtn.click(); return; }
      if(e.key==='g' || e.key==='G'){ toggleGuides.checked=!toggleGuides.checked; toggleGuides.dispatchEvent(new Event('change')); return; }
      if(e.key==='m' || e.key==='M'){ toggleCutMarks.checked=!toggleCutMarks.checked; applyCutOverlay(); return; }

      if(e.key==='Home'){ e.preventDefault(); showPage(0); return; }
      if(e.key==='End'){ e.preventDefault(); showPage(pages.length-1); return; }

      if((e.ctrlKey || e.metaKey) && (e.key==='ArrowLeft' || e.key==='ArrowRight')){
        e.preventDefault();
        if(e.key==='ArrowLeft') showPage(Math.max(0, currentPage-1));
        else showPage(Math.min(pages.length-1, currentPage+1));
        return;
      }
      if(e.key==='['){ e.preventDefault(); showPage(Math.max(0, currentPage-1)); return; }
      if(e.key===']'){ e.preventDefault(); showPage(Math.min(pages.length-1, currentPage+1)); return; }

      if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key) && !e.altKey && !e.ctrlKey && !e.metaKey){
        const m = getCurrent();
        const cell = document.activeElement?.closest?.('.cell') || m.cells[0];
        const i = Number(cell.dataset.index || 0);
        let j = i;
        if (e.key==='ArrowLeft'  && (i%cols)>0) j = i-1;
        if (e.key==='ArrowRight' && (i%cols)<cols-1) j = i+1;
        if (e.key==='ArrowUp'    && i-cols>=0) j = i-cols;
        if (e.key==='ArrowDown'  && i+cols<CELLS_PER_PAGE) j = i+cols;
        if (j !== i){
          e.preventDefault();
          m.cells[j].focus();
        }
        return;
      }

      if(e.key==='n' || e.key==='N'){ e.preventDefault(); addPage(); return; }

      if((e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && (e.key==='c' || e.key==='C')){
        const cell = document.activeElement && document.activeElement.closest ? document.activeElement.closest('.cell') : null;
        if(cell){
          const resolved = resolveModelFromCellEl(cell);
          if(resolved && resolved.model){
            e.preventDefault();
            copyCellImage(resolved.model, resolved.index);
            return;
          }
        }
      }

      const isDel = (e.key==='Delete' || e.key==='Backspace');

      if((e.ctrlKey || e.metaKey) && e.shiftKey && isDel){
        e.preventDefault();
        clearAllPages(true);
        return;
      }

      if((e.ctrlKey || e.metaKey) && !e.shiftKey && isDel){
        e.preventDefault();
        clearCurrentPage();
        return;
      }

      if(e.shiftKey && !e.ctrlKey && !e.metaKey && isDel){
        e.preventDefault();
        removeCurrentPage(true);
        return;
      }

      if(isDel){
        const el = document.activeElement;
        const cell = el && el.classList && el.classList.contains('cell') ? el : null;
        if(cell){
          const idx = Number(cell.dataset.index);
          const m = getCurrent();
          if (m.items[idx]){
            discardItem(m.items[idx]);
            m.items[idx] = null;
            renderCell(m, idx);
            saveState();
          }
          e.preventDefault();
          return;
        }
      }

      if(e.altKey && ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)){
        const cell = document.activeElement?.closest?.('.cell');
        if(!cell) return;
        const i = Number(cell.dataset.index);
        const m = getCurrent();
        let j = i;
        if (e.key==='ArrowLeft' && (i%cols)>0) j=i-1;
        if (e.key==='ArrowRight' && (i%cols)<cols-1) j=i+1;
        if (e.key==='ArrowUp' && i-cols>=0) j=i-cols;
        if (e.key==='ArrowDown' && i+cols<CELLS_PER_PAGE) j=i+cols;
        if (j!==i){
          handleInternalDrop(m, i, m, j);
          m.cells[j].focus();
          saveState();
          e.preventDefault();
        }
      }

      if(/^([1-9])$/.test(e.key)){
        const n = parseInt(e.key,10)-1;
        const cell = getCurrent().cells[n]; if(cell){ cell.focus(); }
        return;
      }
    });

    /* ===== Help/Deck/Tune modal binds ===== */
    if (helpBtn){
      helpBtn.addEventListener('click', function(){
        var modal = ensureHelpModal();
        openModal(modal);
      });
    }

    if (decklistBtn){
      decklistBtn.addEventListener('click', function(){
        var modal = ensureDeckModal();
        openModal(modal);
        if (deckText){ deckText.focus(); }
      });
    }

    /* ===== Width/Height scale lock syncing ===== */
    function syncFromWidth(){
      if (!tuneScaleLock || !tuneScaleLock.checked) return;
      const w = parseFloat(tuneCardWIn.value);
      if (!isFinite(w) || w <= 0) return;
      const s = w / BASE_W_IN;
      const h = s * BASE_H_IN;
      tuneCardHIn.value = h.toFixed(4);
    }
    function syncFromHeight(){
      if (!tuneScaleLock || !tuneScaleLock.checked) return;
      const h = parseFloat(tuneCardHIn.value);
      if (!isFinite(h) || h <= 0) return;
      const s = h / BASE_H_IN;
      const w = s * BASE_W_IN;
      tuneCardWIn.value = w.toFixed(4);
    }

    if (tuneCardWIn){
      tuneCardWIn.addEventListener('input',  syncFromWidth);
      tuneCardWIn.addEventListener('change', syncFromWidth);
    }
    if (tuneCardHIn){
      tuneCardHIn.addEventListener('input',  syncFromHeight);
      tuneCardHIn.addEventListener('change', syncFromHeight);
    }

    /* ===== Basics filtering ===== */
    var BASE_FIVE = new Set(['plains','island','swamp','mountain','forest']);
    var BASIC_BASENAMES = new Set(Array.from(BASE_FIVE).concat(['wastes']));

    function normalizeCardName(raw){
      var s = String(raw).trim();
      s = s.replace(/\s*(?:\[[^\]]+\]|\([^)]+\))\s*$/,'').trim();
      return s.toLowerCase();
    }
    function isBasic(name){ return BASIC_BASENAMES.has(normalizeCardName(name)); }
    function isSnowCoveredBasic(name){
      var s = normalizeCardName(name);
      if (s.indexOf('snow-covered ') !== 0) return false;
      var base = s.slice('snow-covered '.length);
      return BASE_FIVE.has(base);
    }
    function filterBasics(list, ignoreBasics, ignoreSnow){
      return list.filter(function(n){
        if (ignoreBasics && isBasic(n)) return false;
        if (ignoreSnow && isSnowCoveredBasic(n)) return false;
        return true;
      });
    }

    /* ===== Scryfall (search & decklist) ===== */
    const scryCache = new Map();

    function pickImageFromUris(obj){
      if(!obj || !obj.image_uris) return null;
      return obj.image_uris.png || obj.image_uris.large || obj.image_uris.normal || null;
    }

    function makeCardImages(card){
      if(!card) return { front: null, back: null };
      const faces = Array.isArray(card.card_faces) ? card.card_faces : [];
      const front = pickImageFromUris(card) || pickImageFromUris(faces[0]) || null;
      const back = faces.length > 1 ? (pickImageFromUris(faces[1]) || null) : null;
      return { front, back };
    }

    function normalizeCardImages(value){
      if(!value) return null;
      if(typeof value === 'string') return { front: value, back: null };
      const front = value.front || null;
      const back = value.back || null;
      return { front, back };
    }

    function splitNameAndSet(raw){
      let s = String(raw).trim();
      const qm = s.match(/^(\d+)\s*x?\s+(.+)$/i);
      if (qm) s = qm[2];
      let set = null, name = s;
      const m1 = s.match(/\s*\[([A-Za-z0-9]{2,5})\]\s*$/);
      const m2 = s.match(/\s*\(([A-Za-z0-9]{2,5})\)\s*$/);
      if (m1){ set = m1[1]; name = s.slice(0, m1.index).trim(); }
      else if (m2){ set = m2[1]; name = s.slice(0, m2.index).trim(); }
      return { name, set };
    }

    async function fetchCardByName(name){
      const { name: base, set } = splitNameAndSet(name);
      var url = set
        ? 'https://api.scryfall.com/cards/named?exact='+encodeURIComponent(base)+'&set='+encodeURIComponent(set)
        : 'https://api.scryfall.com/cards/named?exact='+encodeURIComponent(base);
      var r = await fetch(url); if(!r.ok) throw new Error('Not found: '+name); var data = await r.json();
      const images = makeCardImages(data);
      if(!images.front) throw new Error('No image for: '+name);
      return images;
    }

    async function addCardByName(name){
      try{
        setStatus('Fetching: '+name);
        const key = name.toLowerCase();
        let images = scryCache.get(key);
        if(images){
          images = normalizeCardImages(images);
        }else{
          images = normalizeCardImages(await fetchCardByName(name));
        }
        if(!images || !images.front) throw new Error('No image for: '+name);
        const includeBacks = !!(includeDFCBacksChk && includeDFCBacksChk.checked);
        scryCache.set(key, images);
        await addImageSrcToNextCell(images.front);
        if(includeBacks && images.back){
          await addImageSrcToNextCell(images.back);
        }
        setStatus('Added');
      } catch(err){ console.error(err); setStatus('Error: '+err.message); }
    }

    function parseDecklist(text){
      const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      const out = [];
      for (let line of lines){
        if (/^(sideboard|companions?|commander)\s*:?\s*$/i.test(line)) continue;
        const m = line.match(/^(\d+)\s*x?\s+(.+)$/i);
        if (m){
          const cnt = parseInt(m[1],10);
          const name = m[2].trim();
          for (let j=0;j<cnt;j++) out.push(name);
        } else {
          out.push(line);
        }
      }
      return out;
    }

    async function addImageSrcToNextCell(src){
      var pos = nextEmptySlot(currentPage) || ensurePageForAppend();
      var m = pages[pos.page];
      if (!m) return;
      try{
        const item = await createItemFromSrc(src);
        if (!item) return;
        placeImage(m, pos.index, item);
      }catch(err){
        console.error('Failed to add image to cell', err);
      }
    }

    async function fetchManyByName(names){
      const results = new Map();
      const toFetch = [];
      for (const original of names){
        const key = original.toLowerCase();
        if (scryCache.has(key)) {
          const cached = normalizeCardImages(scryCache.get(key));
          if (cached && cached.front){
            scryCache.set(key, cached);
            results.set(original, cached);
            continue;
          }
        }
        const { name, set } = splitNameAndSet(original);
        toFetch.push({ original, identifier: set ? { name, set: set.toLowerCase() } : { name } });
      }
      for (let i=0;i<toFetch.length;i+=75){
        const chunk = toFetch.slice(i, i+75);
        let data = null;
        try{
          const r = await fetch('https://api.scryfall.com/cards/collection', {
            method: 'POST',
            headers: { 'Content-Type':'application/json' },
            body: JSON.stringify({ identifiers: chunk.map(x=>x.identifier) })
          });
          if (r.ok) data = await r.json();
        }catch(_){}
        if (!data || !Array.isArray(data.data)) {
          for (const item of chunk){
            try{
              const images = await fetchCardByName(item.original);
              if(images && images.front){
                results.set(item.original, images);
                scryCache.set(item.original.toLowerCase(), images);
              }
            }catch(_){}
          }
          continue;
        }
        let di = 0;
        for (let j=0;j<chunk.length;j++){
          const req = chunk[j];
          const card = data.data[di];
          const wantName = (req.identifier.name||'').normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase();
          const wantSet = req.identifier.set ? req.identifier.set.toLowerCase() : null;
          let matched = false;
          if (card){
            const gotName = (card.name || card.printed_name || '').normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase();
            const gotSet  = (card.set || '').toLowerCase();
            if (gotName === wantName && (!wantSet || gotSet === wantSet)) {
              const images = makeCardImages(card);
              if (images.front){
                results.set(req.original, images);
                scryCache.set(req.original.toLowerCase(), images);
                matched = true;
                di++;
              }
            }
          }
          if (!matched){
            try{
              const images = await fetchCardByName(req.original);
              if(images && images.front){
                results.set(req.original, images);
                scryCache.set(req.original.toLowerCase(), images);
              }
            }catch(_){}
          }
        }
      }
      return results;
    }

    async function importDecklist(text){
      const namesAll = parseDecklist(text);
      const ignoreBasics = !!(ignoreBasicsChk && ignoreBasicsChk.checked);
      const ignoreSnow = !!(ignoreSnowChk && ignoreSnowChk.checked);
      const includeBacks = !!(includeDFCBacksChk && includeDFCBacksChk.checked);
      const names = filterBasics(namesAll, ignoreBasics, ignoreSnow);
      setStatus('Fetching deck images…');

      const mapping = await fetchManyByName(names);
      let placed = 0, missing = 0;
      const pause = ((typeof window !== 'undefined' ? window.requestIdleCallback : null) || setTimeout);
      let batchCount = 0;
      for (const n of names){
        const found = mapping.get(n) || scryCache.get(n.toLowerCase());
        const images = normalizeCardImages(found);
        if (!images || !images.front) { console.warn('No image for', n); missing++; continue; }
        await addImageSrcToNextCell(images.front);
        batchCount++;
        if (includeBacks && images.back){
          await addImageSrcToNextCell(images.back);
          batchCount++;
        }
        setStatus(`(${++placed}/${names.length}) ${n}`);
        if (batchCount >= 16){
          batchCount = 0;
          await new Promise(r => pause === setTimeout ? pause(r, 0) : pause(r, { timeout: 0 }));
        }
      }
      setStatus(missing ? `Done — ${missing} not found` : 'Done');
      showPage(currentPage);
    }

    addCardBtn.addEventListener('click', function(){
      var name=cardSearch.value.trim();
      if(name){ addCardByName(name); cardSearch.select(); }
    });

    /* ===== Status & persistence ===== */
    let statusTimer = null;
    function setStatus(msg){ clearTimeout(statusTimer); statusTimer = setTimeout(()=>{ statusEl.textContent = msg||'Ready'; }, 16); }

    function serializeItem(item){
      if (!item || typeof item !== 'object') return null;
      if (item.type === 'stored' && item.key){
        return { type: 'stored', key: item.key, mime: item.mime || null };
      }
      if (item.type === 'url' && item.url){
        return { type: 'url', url: item.url };
      }
      if (item.url){
        return { type: 'url', url: item.url };
      }
      return null;
    }

    function saveState(){
      try{
        const pagesState = pages.map(function(page){
          const items = Array.isArray(page.items) ? page.items : [];
          const result = [];
          for (let i=0;i<CELLS_PER_PAGE;i++){
            result.push(serializeItem(items[i] || null));
          }
          return result;
        });
        const state = { pages: pagesState, current: currentPage };
        localStorage.setItem('mtgProxyPages', JSON.stringify(state));
      }catch(err){
        console.error('Failed to save state', err);
      }
    }

    async function loadState(){
      try{
        await imageStoreReady;
        const raw = localStorage.getItem('mtgProxyPages');
        if (!raw) return false;
        const state = JSON.parse(raw);
        if (!state || !Array.isArray(state.pages) || !state.pages.length) return false;
        pageWrap.innerHTML = '';
        pages.length = 0;
        let mutated = false;
        for (let i=0;i<state.pages.length;i++){
          const m = createPage();
          pages.push(m);
          const source = Array.isArray(state.pages[i]) ? state.pages[i] : [];
          const items = new Array(CELLS_PER_PAGE).fill(null);
          for (let j=0;j<CELLS_PER_PAGE;j++){
            const entry = source[j];
            if (!entry){
              items[j] = null;
              continue;
            }
            try{
              if (entry.type === 'stored' && entry.key){
                items[j] = createStoredItemFromKey(entry.key, entry.mime || null);
              } else if (entry.type === 'url' && entry.url){
                items[j] = createUrlItem(entry.url);
              } else if (entry.src && typeof entry.src === 'string'){
                if (isDataUrl(entry.src)){
                  items[j] = await createStoredItemFromDataUrl(entry.src);
                  mutated = true;
                } else {
                  items[j] = createUrlItem(entry.src);
                  mutated = true;
                }
              } else if (typeof entry === 'string'){
                if (isDataUrl(entry)){
                  items[j] = await createStoredItemFromDataUrl(entry);
                  mutated = true;
                } else {
                  items[j] = createUrlItem(entry);
                  mutated = true;
                }
              } else {
                items[j] = null;
              }
            }catch(err){
              console.error('Failed to restore image', err);
              items[j] = null;
              mutated = true;
            }
          }
          m.items = items;
          renderGrid(m);
        }
        showPage(Math.min(Math.max(0, state.current||0), pages.length-1));
        if (mutated){ saveState(); }
        return true;
      }catch(err){
        console.error('Failed to load state', err);
        return false;
      }
    }

    /* ===== Theme + Tuning ===== */
    function bindThemeButton(){
      if (!themeBtn || themeBtn.__bound) return;
      themeBtn.__bound = true;
      themeBtn.addEventListener('click', function(){
        var nowDark = document.documentElement.getAttribute('data-theme') === 'dark';
        setDark(!nowDark);
      });
    }

    function setDark(on){
      if(on){
        document.documentElement.setAttribute('data-theme','dark');
        localStorage.setItem('mtgThemeDark','1');
        if (themeBtn){ themeBtn.textContent='☀️'; themeBtn.title='Switch to light mode'; }
      }else{
        document.documentElement.removeAttribute('data-theme');
        localStorage.setItem('mtgThemeDark','0');
        if (themeBtn){ themeBtn.textContent='🌙'; themeBtn.title='Switch to dark mode'; }
      }
    }
    function loadTheme(){
      var on = localStorage.getItem('mtgThemeDark') === '1';
      setDark(on);
    }
    bindThemeButton();

    function readInchesVar(name, fallback){
      var v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      var m = /(-?\d*\.?\d+)in/.exec(v);
      return m ? parseFloat(m[1]) : (fallback||0);
    }

    function applyTuning(topIn, leftIn, cardWIn, cardHIn){
      // sanitize
      topIn   = Math.max(0, Number(topIn)  || 0);
      leftIn  = Number(leftIn) || 0;
      cardWIn = Number(cardWIn) || readInchesVar('--cell-w', BASE_W_IN);
      cardHIn = Number(cardHIn) || readInchesVar('--cell-h', BASE_H_IN);

      // apply CSS custom properties (in inches so readCssInches() stays exact)
      document.documentElement.style.setProperty('--grid-top', topIn.toFixed(2)+'in');
      document.documentElement.style.setProperty('--grid-left', leftIn.toFixed(2)+'in');
      document.documentElement.style.setProperty('--cell-w', cardWIn.toFixed(4)+'in');
      document.documentElement.style.setProperty('--cell-h', cardHIn.toFixed(4)+'in');

      // persist (merge with any existing fields like scaleLock)
      try{
        const prev = JSON.parse(localStorage.getItem('mtgTuning') || '{}');
        prev.topIn = topIn; prev.leftIn = leftIn; prev.cardWIn = cardWIn; prev.cardHIn = cardHIn;
        localStorage.setItem('mtgTuning', JSON.stringify(prev));
      }catch(_){}

      // reflow: cut overlay + image fits use these values
      pages.forEach(queueCutOverlay);
      doUpdate();
    }

    function loadTuning(){
      try{
        var raw = localStorage.getItem('mtgTuning');
        if(raw){
          var t = JSON.parse(raw)||{};
          applyTuning(
            (typeof t.topIn   !== 'undefined') ? t.topIn   : readInchesVar('--grid-top', .25),
            (typeof t.leftIn  !== 'undefined') ? t.leftIn  : readInchesVar('--grid-left', 0),
            (typeof t.cardWIn !== 'undefined') ? t.cardWIn : readInchesVar('--cell-w', 2.4750),
            (typeof t.cardHIn !== 'undefined') ? t.cardHIn : readInchesVar('--cell-h', 3.4650)
          );
          if (tuneScaleLock){
            tuneScaleLock.checked = (typeof t.scaleLock === 'undefined') ? true : !!t.scaleLock;
          }
        }
      }catch(_){}
    }

    function bindTuneButton(){
      if (!tuneBtn || tuneBtn.__bound) return;
      tuneBtn.__bound = true;
      tuneBtn.addEventListener('click', openTune);
    }

    function openTune(){
      tuneTopIn.value   = readInchesVar('--grid-top', .25).toFixed(2);
      tuneLeftIn.value  = readInchesVar('--grid-left', 0).toFixed(2);
      tuneCardWIn.value = readInchesVar('--cell-w', 2.4750).toFixed(4);
      tuneCardHIn.value = readInchesVar('--cell-h', 3.4650).toFixed(4);

      try{
        const t = JSON.parse(localStorage.getItem('mtgTuning') || '{}');
        if (tuneScaleLock) tuneScaleLock.checked = (typeof t.scaleLock === 'undefined') ? true : !!t.scaleLock;
      }catch(_){
        if (tuneScaleLock) tuneScaleLock.checked = true;
      }

      openModal(tuneModal);
      tuneTopIn.focus();
    }

    bindTuneButton();

    if (saveTuneBtn){
      saveTuneBtn.addEventListener('click', function(){
        let w = parseFloat(tuneCardWIn.value);
        let h = parseFloat(tuneCardHIn.value);

        // If locked, enforce 2.5×3.5 ratio using whichever field is valid
        if (tuneScaleLock && tuneScaleLock.checked){
          if (isFinite(w) && w > 0){
            const s = w / BASE_W_IN;
            h = +(s * BASE_H_IN).toFixed(4);
            tuneCardHIn.value = h.toFixed(4);
          } else if (isFinite(h) && h > 0){
            const s = h / BASE_H_IN;
            w = +(s * BASE_W_IN).toFixed(4);
            tuneCardWIn.value = w.toFixed(4);
          }
        }

        applyTuning(
          parseFloat(tuneTopIn.value),
          parseFloat(tuneLeftIn.value),
          w,
          h
        );

        // Persist scaleLock merged with other tuning
        try{
          const prev = JSON.parse(localStorage.getItem('mtgTuning') || '{}');
          prev.scaleLock = !!(tuneScaleLock && tuneScaleLock.checked);
          localStorage.setItem('mtgTuning', JSON.stringify(prev));
        }catch(_){}

        closeModal(tuneModal);
      });
    }

    if (resetTuneBtn){
      resetTuneBtn.addEventListener('click', function(){
        tuneTopIn.value   = '0.25';
        tuneLeftIn.value  = '0.00';
        tuneCardWIn.value = '2.4750';
        tuneCardHIn.value = '3.4650';
        if (tuneScaleLock) tuneScaleLock.checked = true;
      });
    }

    if (closeTuneBtn){
      closeTuneBtn.addEventListener('click', function(){
        closeModal(tuneModal);
      });
    }

    /* Close any modal with Esc or by clicking the backdrop (restore focus) */
    document.addEventListener('keydown', function(e){
      if (e.key === 'Escape'){
        var open = document.querySelector('.modal.open');
        if (open){ e.preventDefault(); closeModal(open); }
      }
    });
    setupModalBackdrop(tuneModal);

    /* ===== Context Menu ===== */
    function ctxIsOpen(){ return !!(ctxMenu && ctxMenu.classList.contains('open')); }

    function ctxEnabledItems(){
      if (!ctxMenu) return [];
      return Array.from(ctxMenu.querySelectorAll('.ctx-item')).filter(function(el){
        return el.getAttribute('aria-disabled') !== 'true';
      });
    }

    function ctxHide(){
      if (!ctxMenu) return;
      const wasOpen = ctxMenu.classList.contains('open');
      const focusEl = ctxTarget && ctxTarget.focusEl && typeof ctxTarget.focusEl.focus === 'function'
        ? ctxTarget.focusEl
        : null;
      ctxMenu.classList.remove('open');
      ctxMenu.setAttribute('aria-hidden', 'true');
      ctxMenu.innerHTML = '';
      ctxTarget = null;
      if (wasOpen && focusEl){
        setTimeout(function(){
          try{ focusEl.focus({ preventScroll: true }); }
          catch(_){ focusEl.focus(); }
        }, 0);
      }
    }

    function ctxShow(x, y, builder){
      if (!ctxMenu) return;
      ctxMenu.innerHTML = '';
      ctxMenu.classList.remove('open');
      ctxMenu.setAttribute('aria-hidden', 'true');
      if (typeof builder === 'function'){ builder(ctxMenu); }
      if (!ctxMenu.firstElementChild){
        ctxHide();
        return;
      }
      ctxMenu.style.left = x + 'px';
      ctxMenu.style.top = y + 'px';
      ctxMenu.classList.add('open');
      ctxMenu.setAttribute('aria-hidden', 'false');

      requestAnimationFrame(function(){
        if (!ctxIsOpen()) return;
        const rect = ctxMenu.getBoundingClientRect();
        const vw = window.innerWidth || document.documentElement.clientWidth || rect.width;
        const vh = window.innerHeight || document.documentElement.clientHeight || rect.height;
        let left = x;
        let top = y;
        if (left + rect.width > vw){ left = Math.max(8, vw - rect.width - 8); }
        if (top + rect.height > vh){ top = Math.max(8, vh - rect.height - 8); }
        ctxMenu.style.left = left + 'px';
        ctxMenu.style.top = top + 'px';
        const first = ctxMenu.querySelector('.ctx-item[aria-disabled="false"]');
        if (first){ first.focus(); }
      });
    }

    function ctxSection(label){
      const sec = document.createElement('div');
      sec.className = 'ctx-section';
      if (label){
        const lbl = document.createElement('div');
        lbl.className = 'ctx-label';
        lbl.textContent = label;
        sec.appendChild(lbl);
      }
      return sec;
    }

    function ctxSeparator(){
      const el = document.createElement('div');
      el.className = 'ctx-sep';
      el.setAttribute('role', 'separator');
      return el;
    }

    function ctxItem(label, onSelect, opts){
      opts = opts || {};
      const el = document.createElement('div');
      el.className = 'ctx-item';
      el.setAttribute('role', 'menuitem');
      const disabled = !!opts.disabled;
      el.setAttribute('aria-disabled', disabled ? 'true' : 'false');
      el.tabIndex = disabled ? -1 : 0;

      const text = document.createElement('span');
      text.textContent = label;
      el.appendChild(text);

      if (opts.kbd){
        const hint = document.createElement('span');
        hint.className = 'ctx-kbd';
        hint.textContent = opts.kbd;
        el.appendChild(hint);
      }

      if (!disabled){
        const activate = function(evt){
          if (evt){ evt.preventDefault(); }
          const handler = onSelect;
          ctxHide();
          if (typeof handler === 'function'){ handler(); }
        };
        el.addEventListener('click', activate);
        el.addEventListener('keydown', function(e){
          if (e.key === 'Enter' || e.key === ' '){ activate(e); }
        });
      }

      return el;
    }

    function moveCell(model, index, direction){
      if (!model || !model.items[index]) return false;
      const offsets = { up: -cols, down: cols, left: -1, right: 1 };
      const delta = offsets[direction];
      if (!delta && delta !== 0) return false;
      if (direction === 'left' && (index % cols) === 0) return false;
      if (direction === 'right' && (index % cols) === cols - 1) return false;
      if (direction === 'up' && index - cols < 0) return false;
      if (direction === 'down' && index + cols >= CELLS_PER_PAGE) return false;
      const target = index + delta;
      handleInternalDrop(model, index, model, target);
      if (model.cells[target] && typeof model.cells[target].focus === 'function'){
        model.cells[target].focus();
      }
      return true;
    }

    async function duplicateToNextEmpty(model, index){
      if (!model || !model.items[index]) return null;
      const src = model.items[index];
      const pageIdx = pages.indexOf(model);
      if (pageIdx === -1) return null;
      let slot = nextEmptySlotFrom({ page: pageIdx, index: index + 1 });
      if (!slot){
        slot = ensurePageForAppend();
      }
      const dstModel = pages[slot.page];
      if (!dstModel) return null;
      try{
        const clone = await cloneItem(src);
        if (!clone) return null;
        const prev = dstModel.items[slot.index];
        if (prev && prev !== clone){ discardItem(prev); }
        dstModel.items[slot.index] = clone;
        renderCell(dstModel, slot.index);
        saveState();
        return slot;
      }catch(err){
        console.error('Failed to duplicate image', err);
        return null;
      }
    }

    function buildCellMenu(model, index, rootEl){
      if (!model || !rootEl) return;
      const pageIdx = pages.indexOf(model);
      const hasImage = !!model.items[index];
      const cellSection = ctxSection('Cell');
      cellSection.appendChild(ctxItem('Replace image…', function(){
        if (pageIdx === -1) return;
        targetIndexForFile = { page: pageIdx, index: index };
        fileInput.click();
      }));
      cellSection.appendChild(ctxItem('Duplicate to next empty cell', function(){
        duplicateToNextEmpty(model, index);
      }, { disabled: !hasImage }));
      cellSection.appendChild(ctxItem('Clear cell', function(){
        if (!model.items[index]) return;
        discardItem(model.items[index]);
        model.items[index] = null;
        renderCell(model, index);
        saveState();
      }, { disabled: !hasImage, kbd: 'Delete' }));

      if (cellSection.querySelectorAll('.ctx-item').length){
        rootEl.appendChild(cellSection);
      }

      const clipboardSection = ctxSection('Clipboard');
      const canCopy = clipboardCanWriteImage();
      const canPaste = clipboardCanReadImage();
      if (hasImage){
        clipboardSection.appendChild(ctxItem('Copy image', function(){ copyCellImage(model, index); }, { disabled: !canCopy, kbd: MOD_KEY_LABEL + '+C' }));
      }
      clipboardSection.appendChild(ctxItem('Paste image', function(){
        const pageIdx = pages.indexOf(model);
        pasteImageFromClipboard({ model: model, index: index, pageIndex: pageIdx >= 0 ? pageIdx : currentPage, allowOverwrite: true });
      }, { disabled: !canPaste, kbd: MOD_KEY_LABEL + '+V' }));
      if(!canCopy && !canPaste){
        clipboardSection.appendChild(ctxItem(CLIPBOARD_UNAVAILABLE_MSG, null, { disabled: true }));
      }

      if (clipboardSection.querySelectorAll('.ctx-item').length){
        if (rootEl.childElementCount){ rootEl.appendChild(ctxSeparator()); }
        rootEl.appendChild(clipboardSection);
      }

      const reorderSection = ctxSection('Reorder');
      const canUp = index - cols >= 0;
      const canDown = index + cols < CELLS_PER_PAGE;
      const canLeft = (index % cols) > 0;
      const canRight = (index % cols) < cols - 1;
      reorderSection.appendChild(ctxItem('Move up', function(){ moveCell(model, index, 'up'); }, { disabled: !hasImage || !canUp, kbd: 'Alt+↑' }));
      reorderSection.appendChild(ctxItem('Move down', function(){ moveCell(model, index, 'down'); }, { disabled: !hasImage || !canDown, kbd: 'Alt+↓' }));
      reorderSection.appendChild(ctxItem('Move left', function(){ moveCell(model, index, 'left'); }, { disabled: !hasImage || !canLeft, kbd: 'Alt+←' }));
      reorderSection.appendChild(ctxItem('Move right', function(){ moveCell(model, index, 'right'); }, { disabled: !hasImage || !canRight, kbd: 'Alt+→' }));

      if (reorderSection.querySelectorAll('.ctx-item').length){
        if (rootEl.childElementCount){ rootEl.appendChild(ctxSeparator()); }
        rootEl.appendChild(reorderSection);
      }
    }

    function buildPageMenu(rootEl){
      if (!rootEl) return;
      const pageIdx = (ctxTarget && typeof ctxTarget.pageIndex === 'number') ? ctxTarget.pageIndex : currentPage;
      const model = pages[pageIdx] || null;
      const hasContent = !!(model && model.items && model.items.some(Boolean));

      const clipboardSection = ctxSection('Clipboard');
      const canPaste = clipboardCanReadImage();
      clipboardSection.appendChild(ctxItem('Paste image(s) onto this page', function(){
        const targetPage = (ctxTarget && typeof ctxTarget.pageIndex === 'number') ? ctxTarget.pageIndex : pageIdx;
        pasteImageFromClipboard({ pageIndex: targetPage });
      }, { disabled: !canPaste, kbd: MOD_KEY_LABEL + '+V' }));
      if(!canPaste){
        clipboardSection.appendChild(ctxItem(CLIPBOARD_UNAVAILABLE_MSG, null, { disabled: true }));
      }

      if (clipboardSection.querySelectorAll('.ctx-item').length){
        rootEl.appendChild(clipboardSection);
      }

      const pageSection = ctxSection('Page');
      pageSection.appendChild(ctxItem('Add page', function(){ addPage(); }, { kbd: 'N' }));
      pageSection.appendChild(ctxItem('Remove this page', function(){
        if (pageIdx !== currentPage) showPage(pageIdx);
        removeCurrentPage(true);
      }, { disabled: pages.length <= 1, kbd: 'Shift+Del' }));
      pageSection.appendChild(ctxItem('Clear this page', function(){
        if (pageIdx !== currentPage) showPage(pageIdx);
        clearCurrentPage();
      }, { disabled: !hasContent, kbd: 'Ctrl+Del' }));
      pageSection.appendChild(ctxItem('Clear all pages', function(){ clearAllPages(true); }, { kbd: 'Ctrl+Shift+Del' }));

      if (pageSection.querySelectorAll('.ctx-item').length){
        if (rootEl.childElementCount){ rootEl.appendChild(ctxSeparator()); }
        rootEl.appendChild(pageSection);
      }

      const displaySection = ctxSection('Display');
      displaySection.appendChild(ctxItem('Toggle guides', function(){
        toggleGuides.checked = !toggleGuides.checked;
        toggleGuides.dispatchEvent(new Event('change'));
      }, { kbd: 'G' }));
      displaySection.appendChild(ctxItem('Toggle cut marks', function(){
        toggleCutMarks.checked = !toggleCutMarks.checked;
        applyCutOverlay();
      }, { kbd: 'M' }));

      if (displaySection.querySelectorAll('.ctx-item').length){
        if (rootEl.childElementCount){ rootEl.appendChild(ctxSeparator()); }
        rootEl.appendChild(displaySection);
      }

      const appSection = ctxSection('Application');
      appSection.appendChild(ctxItem('Print…', function(){ printBtn.click(); }, { kbd: 'P' }));
      appSection.appendChild(ctxItem('Help & hotkeys', function(){ openModal(ensureHelpModal()); }, { kbd: '?' }));

      if (appSection.querySelectorAll('.ctx-item').length){
        if (rootEl.childElementCount){ rootEl.appendChild(ctxSeparator()); }
        rootEl.appendChild(appSection);
      }
    }

    function ctxHandleOutsidePointer(e){
      if (!ctxIsOpen()) return;
      if (ctxMenu && ctxMenu.contains(e.target)) return;
      ctxHide();
    }
    document.addEventListener('pointerdown', ctxHandleOutsidePointer);
    document.addEventListener('mousedown', ctxHandleOutsidePointer);
    window.addEventListener('wheel', function(){ ctxHide(); }, { passive: true, capture: true });
    document.addEventListener('scroll', function(){ ctxHide(); }, true);
    window.addEventListener('resize', ctxHide);
    window.addEventListener('blur', ctxHide);

    document.addEventListener('keydown', function(e){
      if (!ctxIsOpen()) return;
      const items = ctxEnabledItems();
      if (e.key === 'Escape'){
        e.preventDefault();
        e.stopImmediatePropagation();
        ctxHide();
        return;
      }
      if (!items.length) return;
      const current = items.indexOf(document.activeElement);
      if (e.key === 'Tab'){
        e.preventDefault();
        e.stopImmediatePropagation();
        const next = e.shiftKey ? (current <= 0 ? items.length - 1 : current - 1) : (current === items.length - 1 ? 0 : current + 1);
        items[next].focus();
        return;
      }
      if (e.key === 'ArrowDown'){
        e.preventDefault();
        e.stopImmediatePropagation();
        const next = current === -1 ? 0 : (current + 1) % items.length;
        items[next].focus();
        return;
      }
      if (e.key === 'ArrowUp'){
        e.preventDefault();
        e.stopImmediatePropagation();
        const next = current === -1 ? items.length - 1 : (current - 1 + items.length) % items.length;
        items[next].focus();
        return;
      }
      if (e.key === 'Home'){
        e.preventDefault();
        e.stopImmediatePropagation();
        items[0].focus();
        return;
      }
      if (e.key === 'End'){
        e.preventDefault();
        e.stopImmediatePropagation();
        items[items.length - 1].focus();
        return;
      }
      if (!e.altKey && !e.ctrlKey && !e.metaKey){
        e.stopImmediatePropagation();
      }
    }, true);

    if (ctxMenu){
      ctxMenu.addEventListener('contextmenu', function(e){ e.preventDefault(); });
    }

    document.addEventListener('contextmenu', function(e){
      if (!ctxMenu) return;
      const target = e.target;
      if (!target) { ctxHide(); return; }
      if (ctxMenu.contains(target)){ return; }

      const activeCell = document.activeElement && document.activeElement.closest ? document.activeElement.closest('.cell') : null;

      const native = target.closest('input, textarea, select, [contenteditable="true"], [contenteditable=""]');
      if (native){ ctxHide(); return; }

      const cell = target.closest && target.closest('.cell');
      if (cell){
        const resolved = resolveModelFromCellEl(cell);
        if (resolved){
          e.preventDefault();
          ctxTarget = { type: 'cell', model: resolved.model, index: resolved.index, pageIndex: pages.indexOf(resolved.model), focusEl: cell };
          ctxShow(e.clientX, e.clientY, function(root){ buildCellMenu(resolved.model, resolved.index, root); });
          return;
        }
      }

      const page = target.closest && target.closest('.page');
      if (page){
        const pageIndex = pages.findIndex(function(p){ return p.pageEl === page; });
        if (pageIndex !== -1){
          e.preventDefault();
          ctxTarget = { type: 'page', pageIndex: pageIndex, model: pages[pageIndex], focusEl: activeCell };
          ctxShow(e.clientX, e.clientY, function(root){ buildPageMenu(root); });
          return;
        }
      }

      e.preventDefault();
      const pageIndex = Math.max(0, Math.min(currentPage, pages.length ? pages.length - 1 : 0));
      ctxTarget = { type: 'app', pageIndex: pageIndex, model: pages[pageIndex] || null, focusEl: activeCell };
      ctxShow(e.clientX, e.clientY, function(root){ buildPageMenu(root); });
    });

    /* ===== Init ===== */
    (async function init(){
      const firstPage = createPage();
      pages.push(firstPage);
      renderGrid(firstPage);
      let loaded = false;
      try{
        loaded = await loadState();
      }catch(err){
        console.error('Failed to load saved state', err);
      }
      if (!loaded){
        showPage(0);
      }
      applyCutOverlay();
      doUpdate();
      loadTheme();
      loadTuning();
    })();

    // Expose for debugging
    window.__mtgDebug = { pages };
  </script>
</body>
</html>
